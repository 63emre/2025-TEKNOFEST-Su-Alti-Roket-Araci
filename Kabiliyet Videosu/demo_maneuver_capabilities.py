#!/usr/bin/env python3
"""
TEKNOFEST Su Altƒ± Roket Aracƒ± - Manevrabilite Kabiliyeti Demo
Video √ßekimi i√ßin kontroll√º hareket yetenekleri g√∂sterimi
≈ûartname: En az 1 dakika kontroll√º manevralar (seyir, d√∂n√º≈ü, yunuslama)
"""

import time
import threading
import math
from datetime import datetime
from pymavlink import mavutil
import json

# MAVLink baƒülantƒ± adresi
# Serial MAVLink connection with environment variable support
import os  
MAV_ADDRESS = os.getenv("MAV_ADDRESS", "/dev/ttyACM0") + "," + str(os.getenv("MAV_BAUD", "115200"))

# Test parametreleri
DEMO_DEPTH = 2.0          # Demo derinliƒüi (m)
MIN_MANEUVER_TIME = 60    # Minimum 1 dakika (≈üartname)
SURFACE_ASCENT_TEST = True # Y√ºzeye √ßƒ±kƒ±≈ü testi

# Sistem kanallarƒ±
MOTOR_CHANNEL = 8
SERVO_CHANNELS = {
    'fin_top': 1,     # Pitch kontrol√º
    'fin_right': 2,   # Yaw kontrol√º
    'fin_bottom': 3,  # Pitch kontrol√º  
    'fin_left': 4     # Yaw kontrol√º
}

# PWM deƒüerleri
PWM_NEUTRAL = 1500
PWM_MIN = 1000
PWM_MAX = 2000

class ManeuverabilityDemo:
    def __init__(self):
        self.master = None
        self.connected = False
        self.demo_active = False
        
        # Navigation veriler
        self.current_depth = 0.0
        self.current_roll = 0.0
        self.current_pitch = 0.0  
        self.current_yaw = 0.0
        self.current_speed = 0.0
        
        # Position tracking (basit)
        self.position_x = 0.0
        self.position_y = 0.0
        self.start_position = (0.0, 0.0)
        
        # Demo durumu
        self.demo_stage = "PREPARATION"
        self.demo_start_time = None
        self.maneuver_count = 0
        self.total_maneuver_time = 0
        
        # Performance metrikler
        self.max_roll_angle = 0.0
        self.max_pitch_angle = 0.0
        self.max_yaw_rate = 0.0
        self.stability_violations = 0
        
        # Veri kayƒ±t
        self.maneuver_log = []
        self.telemetry_data = []
        
        # Threading
        self.monitoring_thread = None
        self.running = False
        
    def connect_pixhawk(self):
        """Pixhawk baƒülantƒ±sƒ± kur"""
        try:
            print("üîå Pixhawk baƒülantƒ±sƒ± kuruluyor...")
            
            # Handle serial vs TCP connection
            if ',' in MAV_ADDRESS:
                # Serial connection: port,baud
                port, baud = MAV_ADDRESS.split(',')
                print(f"üì° Serial: {port} @ {baud} baud")
                self.master = mavutil.mavlink_connection(port, baud=int(baud), autoreconnect=True)
            else:
                # TCP or other connection
                print(f"üåê TCP: {MAV_ADDRESS}")
                self.master = mavutil.mavlink_connection(MAV_ADDRESS)
            
            print("üíì Heartbeat bekleniyor...")
            self.master.wait_heartbeat(timeout=15)
            
            self.connected = True
            print("‚úÖ MAVLink baƒülantƒ±sƒ± ba≈üarƒ±lƒ±!")
            return True
            
        except Exception as e:
            print(f"‚ùå Baƒülantƒ± hatasƒ±: {e}")
            return False
    
    def read_sensors(self):
        """Sens√∂r verilerini oku"""
        if not self.connected:
            return False
            
        try:
            # Attitude verisi
            attitude_msg = self.master.recv_match(type='ATTITUDE', blocking=False)
            if attitude_msg:
                self.current_roll = math.degrees(attitude_msg.roll)
                self.current_pitch = math.degrees(attitude_msg.pitch)
                self.current_yaw = math.degrees(attitude_msg.yaw)
                
                # Maksimum a√ßƒ±larƒ± kaydet
                self.max_roll_angle = max(self.max_roll_angle, abs(self.current_roll))
                self.max_pitch_angle = max(self.max_pitch_angle, abs(self.current_pitch))
            
            # Derinlik verisi (basƒ±n√ß sens√∂r√ºnden)
            pressure_msg = self.master.recv_match(type='SCALED_PRESSURE', blocking=False)
            if pressure_msg:
                # Basƒ±n√ß farkƒ±ndan derinlik hesapla
                depth_pressure = pressure_msg.press_abs - 1013.25  # Atmosfer basƒ±ncƒ±
                self.current_depth = max(0, depth_pressure * 0.10197)  # hPa to meter
            
            # Hƒ±z verisi (VFR_HUD)
            vfr_msg = self.master.recv_match(type='VFR_HUD', blocking=False)
            if vfr_msg:
                self.current_speed = vfr_msg.groundspeed
            
            # Basit pozisyon tracking (dead reckoning)
            dt = 0.1  # 10Hz update
            self.position_x += self.current_speed * math.cos(math.radians(self.current_yaw)) * dt
            self.position_y += self.current_speed * math.sin(math.radians(self.current_yaw)) * dt
            
            # Telemetri kaydƒ±
            timestamp = time.time()
            self.telemetry_data.append({
                'timestamp': timestamp,
                'depth': self.current_depth,
                'roll': self.current_roll,
                'pitch': self.current_pitch,
                'yaw': self.current_yaw,
                'speed': self.current_speed,
                'position_x': self.position_x,
                'position_y': self.position_y,
                'stage': self.demo_stage
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Sens√∂r okuma hatasƒ±: {e}")
            return False
    
    def check_stability(self):
        """Stabilite kontrol√º (kontroll√º hareket deƒüerlendirmesi i√ßin)"""
        # ≈ûartname: "Kontrols√ºz m√ºdahale veya kararsƒ±z hareket kabul edilmeyecektir"
        
        stability_ok = True
        
        # A≈üƒ±rƒ± roll kontrol√º
        if abs(self.current_roll) > 45:  # 45¬∞ limit
            print(f"‚ö†Ô∏è A≈üƒ±rƒ± roll a√ßƒ±sƒ±: {self.current_roll:.1f}¬∞")
            stability_ok = False
            
        # A≈üƒ±rƒ± pitch kontrol√º  
        if abs(self.current_pitch) > 60:  # 60¬∞ limit
            print(f"‚ö†Ô∏è A≈üƒ±rƒ± pitch a√ßƒ±sƒ±: {self.current_pitch:.1f}¬∞")
            stability_ok = False
            
        if not stability_ok:
            self.stability_violations += 1
            
        return stability_ok
    
    def display_maneuver_status(self):
        """Manevra durumunu g√∂r√ºnt√ºle"""
        print("\n" + "="*70)
        print(f"üé¨ TEKNOFEST - MANEVRABƒ∞Lƒ∞TE DEMOSu - {self.demo_stage}")
        print("="*70)
        
        timestamp = datetime.now().strftime("%H:%M:%S")
        demo_time = (time.time() - self.demo_start_time) if self.demo_start_time else 0
        
        print(f"‚è∞ Zaman: {timestamp} | Demo S√ºresi: {demo_time:.0f}s")
        print(f"üåä Derinlik: {self.current_depth:.1f}m | Hƒ±z: {self.current_speed:.1f} m/s")
        print(f"üß≠ Roll: {self.current_roll:+6.1f}¬∞ | Pitch: {self.current_pitch:+6.1f}¬∞ | Yaw: {self.current_yaw:06.1f}¬∞")
        print(f"üìç Pozisyon: X={self.position_x:+6.1f}m, Y={self.position_y:+6.1f}m")
        print(f"üéØ Tamamlanan Manevralar: {self.maneuver_count} | Toplam S√ºre: {self.total_maneuver_time:.0f}s")
        print(f"‚ö†Ô∏è Stabilite ƒ∞hlalleri: {self.stability_violations}")
        
        # ≈ûartname gereksinimi
        min_time_status = "‚úÖ YETER" if self.total_maneuver_time >= MIN_MANEUVER_TIME else f"‚ùå EKSƒ∞K ({MIN_MANEUVER_TIME}s gerekli)"
        print(f"üìè Minimum S√ºre Gereksinimi: {min_time_status}")
        
        print("="*70)
    
    def set_motor_throttle(self, throttle_pwm):
        """Motor kontrol√º"""
        if not self.connected:
            return False
            
        throttle_pwm = max(PWM_MIN, min(PWM_MAX, throttle_pwm))
        
        try:
            self.master.mav.command_long_send(
                self.master.target_system,
                self.master.target_component,
                mavutil.mavlink.MAV_CMD_DO_SET_SERVO,
                0,
                MOTOR_CHANNEL, throttle_pwm, 0, 0, 0, 0, 0
            )
            return True
        except:
            return False
    
    def set_servo_position(self, channel, pwm_value):
        """Servo kontrol√º"""
        if not self.connected:
            return False
            
        pwm_value = max(PWM_MIN, min(PWM_MAX, pwm_value))
        
        try:
            self.master.mav.command_long_send(
                self.master.target_system,
                self.master.target_component,
                mavutil.mavlink.MAV_CMD_DO_SET_SERVO,
                0,
                channel, pwm_value, 0, 0, 0, 0, 0
            )
            return True
        except:
            return False
    
    def set_control_surfaces(self, roll_cmd=0, pitch_cmd=0, yaw_cmd=0):
        """Kontrol y√ºzeyleri (finler) ayarla"""
        # Fin mixing algoritmasƒ±
        fin_commands = {
            'fin_top': PWM_NEUTRAL - pitch_cmd + yaw_cmd,      # Pitch/Yaw
            'fin_bottom': PWM_NEUTRAL + pitch_cmd + yaw_cmd,   # Pitch/Yaw
            'fin_right': PWM_NEUTRAL + roll_cmd + yaw_cmd,     # Roll/Yaw
            'fin_left': PWM_NEUTRAL - roll_cmd + yaw_cmd       # Roll/Yaw
        }
        
        # Servo komutlarƒ± g√∂nder
        for fin_name, pwm_value in fin_commands.items():
            channel = SERVO_CHANNELS[fin_name]
            self.set_servo_position(channel, int(pwm_value))
            
        return True
    
    def monitoring_loop(self):
        """S√ºrekli izleme d√∂ng√ºs√º"""
        while self.running and self.demo_active:
            self.read_sensors()
            self.check_stability()
            
            # Her 3 saniyede durum g√∂ster
            if len(self.telemetry_data) % 30 == 0:  # 10Hz * 3s = 30 samples
                self.display_maneuver_status()
            
            time.sleep(0.1)  # 10Hz
    
    def descend_to_demo_depth(self):
        """Demo derinliƒüine in"""
        print(f"\nüéØ Demo derinliƒüine ini≈ü: {DEMO_DEPTH}m")
        
        descend_start = time.time()
        
        while time.time() - descend_start < 90:  # Max 90s ini≈ü s√ºresi
            # Motor ile a≈üaƒüƒ± in
            self.set_motor_throttle(PWM_NEUTRAL - 80)  # Reverse thrust
            
            # Finlerle pitch kontrol√º (a≈üaƒüƒ± yunuslama)
            self.set_control_surfaces(pitch_cmd=100)  # Nose down
            
            self.read_sensors()
            
            print(f"  üìä ƒ∞ni≈ü: {self.current_depth:.1f}m / {DEMO_DEPTH}m | Pitch: {self.current_pitch:.1f}¬∞")
            
            if self.current_depth >= DEMO_DEPTH:
                break
                
            time.sleep(2)
        
        # Finleri n√∂tr pozisyona al
        self.set_control_surfaces()
        self.set_motor_throttle(PWM_NEUTRAL)
        
        if self.current_depth < DEMO_DEPTH * 0.8:  # En az %80'ine inmeli
            print(f"‚ùå Yeterli derinliƒüe inilemedi: {self.current_depth:.1f}m")
            return False
        
        print(f"‚úÖ Demo derinliƒüi: {self.current_depth:.1f}m")
        return True
    
    def maneuver_straight_cruise(self, duration=15):
        """D√ºz seyir manevasƒ±"""
        print(f"\nüöÄ 1. D√úZ SEYƒ∞R MANEVRAsƒ± ({duration}s)")
        
        maneuver_start = time.time()
        initial_yaw = self.current_yaw
        
        while time.time() - maneuver_start < duration:
            elapsed = time.time() - maneuver_start
            remaining = duration - elapsed
            
            # ƒ∞leri motor g√ºc√º
            self.set_motor_throttle(PWM_NEUTRAL + 120)
            
            # Y√∂n stabilizasyonu (heading hold)
            yaw_error = self.current_yaw - initial_yaw
            if yaw_error > 180:
                yaw_error -= 360
            elif yaw_error < -180:
                yaw_error += 360
                
            yaw_correction = int(yaw_error * -3)  # P kontrol
            
            # Pitch stabilizasyonu (level flight) 
            pitch_correction = int(self.current_pitch * -2)
            
            self.set_control_surfaces(yaw_cmd=yaw_correction, pitch_cmd=pitch_correction)
            
            print(f"  üìä D√ºz seyir: {remaining:.0f}s | Hƒ±z: {self.current_speed:.1f} m/s | Yaw error: {yaw_error:.1f}¬∞")
            
            time.sleep(1)
        
        # Motor durdur
        self.set_motor_throttle(PWM_NEUTRAL)
        self.set_control_surfaces()
        
        self.maneuver_count += 1
        self.total_maneuver_time += duration
        
        # Manevra kaydƒ±
        self.maneuver_log.append({
            'maneuver': 'STRAIGHT_CRUISE',
            'duration': duration,
            'initial_yaw': initial_yaw,
            'final_yaw': self.current_yaw,
            'max_speed': max([data['speed'] for data in self.telemetry_data[-int(duration*10):]], default=0),
            'success': True
        })
        
        print("‚úÖ D√ºz seyir tamamlandƒ±!")
        return True
    
    def maneuver_turn_right(self, duration=12, target_angle=90):
        """Saƒüa d√∂n√º≈ü manevasƒ±"""
        print(f"\n‚Ü™Ô∏è 2. SAƒû D√ñN√ú≈û MANEVRAsƒ± ({duration}s, {target_angle}¬∞)")
        
        maneuver_start = time.time()
        initial_yaw = self.current_yaw
        target_yaw = (initial_yaw + target_angle) % 360
        
        while time.time() - maneuver_start < duration:
            elapsed = time.time() - maneuver_start
            remaining = duration - elapsed
            
            # Orta hƒ±z motor g√ºc√º
            self.set_motor_throttle(PWM_NEUTRAL + 80)
            
            # Saƒü d√∂n√º≈ü kontrol√º
            yaw_error = target_yaw - self.current_yaw
            if yaw_error > 180:
                yaw_error -= 360
            elif yaw_error < -180:
                yaw_error += 360
                
            # D√∂n√º≈ü kontrol√º (saƒü finlerin farklƒ± ayarƒ±)
            turn_command = 150 if abs(yaw_error) > 10 else int(yaw_error * 10)
            roll_command = min(100, int(yaw_error * 2))  # Banked turn
            
            self.set_control_surfaces(roll_cmd=roll_command, yaw_cmd=turn_command)
            
            print(f"  üìä Saƒü d√∂n√º≈ü: {remaining:.0f}s | Yaw: {self.current_yaw:.1f}¬∞ -> {target_yaw:.1f}¬∞ | Error: {yaw_error:.1f}¬∞")
            
            # Hedefe yakƒ±n olduk mu?
            if abs(yaw_error) < 5:
                print("  üéØ Hedef a√ßƒ±ya ula≈üƒ±ldƒ±!")
                break
                
            time.sleep(1)
        
        # Stabilize et
        self.set_control_surfaces()
        self.set_motor_throttle(PWM_NEUTRAL)
        
        self.maneuver_count += 1
        self.total_maneuver_time += duration
        
        actual_turn = abs(self.current_yaw - initial_yaw)
        if actual_turn > 180:
            actual_turn = 360 - actual_turn
        
        self.maneuver_log.append({
            'maneuver': 'TURN_RIGHT',
            'duration': duration,
            'target_angle': target_angle,
            'actual_angle': actual_turn,
            'initial_yaw': initial_yaw,
            'final_yaw': self.current_yaw,
            'success': abs(actual_turn - target_angle) < 15
        })
        
        print(f"‚úÖ Saƒü d√∂n√º≈ü tamamlandƒ±! Ger√ßek d√∂n√º≈ü: {actual_turn:.1f}¬∞")
        return True
    
    def maneuver_turn_left(self, duration=12, target_angle=90):
        """Sola d√∂n√º≈ü manevasƒ±"""
        print(f"\n‚Ü©Ô∏è 3. SOL D√ñN√ú≈û MANEVRAsƒ± ({duration}s, {target_angle}¬∞)")
        
        maneuver_start = time.time()
        initial_yaw = self.current_yaw
        target_yaw = (initial_yaw - target_angle) % 360
        
        while time.time() - maneuver_start < duration:
            elapsed = time.time() - maneuver_start
            remaining = duration - elapsed
            
            # Orta hƒ±z motor g√ºc√º
            self.set_motor_throttle(PWM_NEUTRAL + 80)
            
            # Sol d√∂n√º≈ü kontrol√º
            yaw_error = target_yaw - self.current_yaw
            if yaw_error > 180:
                yaw_error -= 360
            elif yaw_error < -180:
                yaw_error += 360
                
            # Sol d√∂n√º≈ü komutlarƒ±
            turn_command = -150 if abs(yaw_error) > 10 else int(yaw_error * 10)
            roll_command = max(-100, int(yaw_error * 2))  # Banked turn (sol)
            
            self.set_control_surfaces(roll_cmd=roll_command, yaw_cmd=turn_command)
            
            print(f"  üìä Sol d√∂n√º≈ü: {remaining:.0f}s | Yaw: {self.current_yaw:.1f}¬∞ -> {target_yaw:.1f}¬∞ | Error: {yaw_error:.1f}¬∞")
            
            if abs(yaw_error) < 5:
                print("  üéØ Hedef a√ßƒ±ya ula≈üƒ±ldƒ±!")
                break
                
            time.sleep(1)
        
        # Stabilize et
        self.set_control_surfaces()
        self.set_motor_throttle(PWM_NEUTRAL)
        
        self.maneuver_count += 1
        self.total_maneuver_time += duration
        
        actual_turn = abs(self.current_yaw - initial_yaw)
        if actual_turn > 180:
            actual_turn = 360 - actual_turn
        
        self.maneuver_log.append({
            'maneuver': 'TURN_LEFT',
            'duration': duration,
            'target_angle': target_angle,
            'actual_angle': actual_turn,
            'initial_yaw': initial_yaw,
            'final_yaw': self.current_yaw,
            'success': abs(actual_turn - target_angle) < 15
        })
        
        print(f"‚úÖ Sol d√∂n√º≈ü tamamlandƒ±! Ger√ßek d√∂n√º≈ü: {actual_turn:.1f}¬∞")
        return True
    
    def maneuver_pitch_up(self, duration=10, target_angle=20):
        """Yukarƒ± yunuslama manevasƒ±"""
        print(f"\nüîº 4. YUKARI YUNUSLAMA ({duration}s, {target_angle}¬∞)")
        
        maneuver_start = time.time()
        initial_pitch = self.current_pitch
        
        while time.time() - maneuver_start < duration:
            elapsed = time.time() - maneuver_start
            remaining = duration - elapsed
            
            # ƒ∞leri motor g√ºc√º
            self.set_motor_throttle(PWM_NEUTRAL + 100)
            
            # Yukarƒ± yunuslama (pitch up)
            pitch_error = target_angle - self.current_pitch
            pitch_command = min(200, max(-200, int(pitch_error * 8)))
            
            # Y√∂n stabilizasyonu
            roll_stabilize = int(self.current_roll * -2)
            
            self.set_control_surfaces(roll_cmd=roll_stabilize, pitch_cmd=-pitch_command)
            
            print(f"  üìä Yunuslama: {remaining:.0f}s | Pitch: {self.current_pitch:.1f}¬∞ -> {target_angle}¬∞ | Derinlik: {self.current_depth:.1f}m")
            
            time.sleep(1)
        
        # Stabilize et
        self.set_control_surfaces()
        self.set_motor_throttle(PWM_NEUTRAL)
        
        self.maneuver_count += 1
        self.total_maneuver_time += duration
        
        max_pitch = max([data['pitch'] for data in self.telemetry_data[-int(duration*10):]], default=0)
        
        self.maneuver_log.append({
            'maneuver': 'PITCH_UP',
            'duration': duration,
            'target_angle': target_angle,
            'max_pitch': max_pitch,
            'initial_pitch': initial_pitch,
            'final_pitch': self.current_pitch,
            'success': max_pitch >= target_angle * 0.7
        })
        
        print(f"‚úÖ Yukarƒ± yunuslama tamamlandƒ±! Max pitch: {max_pitch:.1f}¬∞")
        return True
    
    def maneuver_pitch_down(self, duration=10, target_angle=-20):
        """A≈üaƒüƒ± yunuslama manevasƒ±"""
        print(f"\nüîΩ 5. A≈ûAƒûI YUNUSLAMA ({duration}s, {target_angle}¬∞)")
        
        maneuver_start = time.time()
        initial_pitch = self.current_pitch
        
        while time.time() - maneuver_start < duration:
            elapsed = time.time() - maneuver_start
            remaining = duration - elapsed
            
            # ƒ∞leri motor g√ºc√º
            self.set_motor_throttle(PWM_NEUTRAL + 100)
            
            # A≈üaƒüƒ± yunuslama (pitch down)
            pitch_error = target_angle - self.current_pitch
            pitch_command = min(200, max(-200, int(pitch_error * 8)))
            
            # Y√∂n stabilizasyonu
            roll_stabilize = int(self.current_roll * -2)
            
            self.set_control_surfaces(roll_cmd=roll_stabilize, pitch_cmd=-pitch_command)
            
            print(f"  üìä Yunuslama: {remaining:.0f}s | Pitch: {self.current_pitch:.1f}¬∞ -> {target_angle}¬∞ | Derinlik: {self.current_depth:.1f}m")
            
            time.sleep(1)
        
        # Stabilize et
        self.set_control_surfaces()
        self.set_motor_throttle(PWM_NEUTRAL)
        
        self.maneuver_count += 1
        self.total_maneuver_time += duration
        
        min_pitch = min([data['pitch'] for data in self.telemetry_data[-int(duration*10):]], default=0)
        
        self.maneuver_log.append({
            'maneuver': 'PITCH_DOWN',
            'duration': duration,
            'target_angle': target_angle,
            'min_pitch': min_pitch,
            'initial_pitch': initial_pitch,
            'final_pitch': self.current_pitch,
            'success': min_pitch <= target_angle * 0.7
        })
        
        print(f"‚úÖ A≈üaƒüƒ± yunuslama tamamlandƒ±! Min pitch: {min_pitch:.1f}¬∞")
        return True
    
    def maneuver_surface_ascent(self, duration=20):
        """Y√ºzeye √ßƒ±kƒ±≈ü manevasƒ± (≈üartname gereƒüi)"""
        print(f"\nüåä 6. Y√úZEYE √áIKI≈û MANEVRAsƒ± ({duration}s)")
        print("üìã ≈ûartname: ƒ∞kinci g√∂revde burun kapaƒüƒ± a√ßƒ±lmadan y√ºzeye √ßƒ±kƒ±≈ü")
        
        maneuver_start = time.time()
        initial_depth = self.current_depth
        
        while time.time() - maneuver_start < duration:
            elapsed = time.time() - maneuver_start
            remaining = duration - elapsed
            
            # Yukarƒ± motor g√ºc√º
            self.set_motor_throttle(PWM_NEUTRAL + 150)
            
            # Yukarƒ± pitch
            self.set_control_surfaces(pitch_cmd=-150)  # Nose up
            
            print(f"  üìä Y√ºzeye √ßƒ±kƒ±≈ü: {remaining:.0f}s | Derinlik: {self.current_depth:.1f}m | Pitch: {self.current_pitch:.1f}¬∞")
            
            # Y√ºzeye √ßƒ±ktƒ±k mƒ±?
            if self.current_depth < 0.5:  # 0.5m altƒ±na √ßƒ±ktƒ±k
                print("  üåä Y√ºzey seviyesine ula≈üƒ±ldƒ±!")
                break
                
            time.sleep(1)
        
        # Y√ºzeyde stabilize
        self.set_motor_throttle(PWM_NEUTRAL)
        self.set_control_surfaces()
        
        self.maneuver_count += 1
        self.total_maneuver_time += duration
        
        depth_change = initial_depth - self.current_depth
        
        self.maneuver_log.append({
            'maneuver': 'SURFACE_ASCENT',
            'duration': duration,
            'initial_depth': initial_depth,
            'final_depth': self.current_depth,
            'depth_change': depth_change,
            'success': self.current_depth < 1.0
        })
        
        print(f"‚úÖ Y√ºzeye √ßƒ±kƒ±≈ü tamamlandƒ±! Derinlik deƒüi≈üimi: {depth_change:.1f}m")
        return True
    
    def return_to_start_position(self, duration=25):
        """Ba≈ülangƒ±√ß noktasƒ±na d√∂n√º≈ü (bonus manevra)"""
        print(f"\nüè† 7. BA≈ûLANGI√á POZƒ∞SYONUNA D√ñN√ú≈û ({duration}s)")
        
        # Ba≈ülangƒ±√ß noktasƒ±na olan mesafe
        distance_to_start = math.sqrt(self.position_x**2 + self.position_y**2)
        bearing_to_start = math.degrees(math.atan2(-self.position_y, -self.position_x))
        
        print(f"  üìç Mesafe: {distance_to_start:.1f}m | Y√∂n: {bearing_to_start:.0f}¬∞")
        
        maneuver_start = time.time()
        
        while time.time() - maneuver_start < duration:
            elapsed = time.time() - maneuver_start
            remaining = duration - elapsed
            
            # Ba≈ülangƒ±√ß noktasƒ±na y√∂n
            current_distance = math.sqrt(self.position_x**2 + self.position_y**2)
            
            if current_distance > 2.0:  # 2m'den uzaksa
                # Ba≈ülangƒ±ca doƒüru git
                target_bearing = math.degrees(math.atan2(-self.position_y, -self.position_x))
                
                bearing_error = target_bearing - self.current_yaw
                if bearing_error > 180:
                    bearing_error -= 360
                elif bearing_error < -180:
                    bearing_error += 360
                
                # Motor ve fin kontrol√º
                self.set_motor_throttle(PWM_NEUTRAL + 100)
                yaw_cmd = max(-100, min(100, int(bearing_error * 2)))
                self.set_control_surfaces(yaw_cmd=yaw_cmd)
                
                print(f"  üìä D√∂n√º≈ü: {remaining:.0f}s | Mesafe: {current_distance:.1f}m | Bearing error: {bearing_error:.1f}¬∞")
            else:
                print(f"  üéØ Ba≈ülangƒ±√ß noktasƒ±na yakƒ±n: {current_distance:.1f}m")
                self.set_motor_throttle(PWM_NEUTRAL)
                self.set_control_surfaces()
                break
                
            time.sleep(1)
        
        final_distance = math.sqrt(self.position_x**2 + self.position_y**2)
        
        self.maneuver_count += 1
        self.total_maneuver_time += duration
        
        self.maneuver_log.append({
            'maneuver': 'RETURN_TO_START',
            'duration': duration,
            'initial_distance': distance_to_start,
            'final_distance': final_distance,
            'success': final_distance < distance_to_start * 0.5
        })
        
        print(f"‚úÖ Ba≈ülangƒ±√ß d√∂n√º≈ü√º tamamlandƒ±! Final mesafe: {final_distance:.1f}m")
        return True
    
    def generate_demo_report(self):
        """Demo test raporu"""
        print("\n" + "="*70)
        print("üìã MANEVRABƒ∞Lƒ∞TE KABƒ∞Lƒ∞YETƒ∞ DEMO RAPORU")
        print("="*70)
        
        demo_duration = time.time() - self.demo_start_time if self.demo_start_time else 0
        
        print(f"üìÖ Demo Tarihi: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"‚è±Ô∏è Toplam Demo S√ºresi: {demo_duration/60:.1f} dakika")
        print(f"üåä Maksimum Derinlik: {max([d['depth'] for d in self.telemetry_data], default=0):.1f}m")
        print(f"üöÄ Maksimum Hƒ±z: {max([d['speed'] for d in self.telemetry_data], default=0):.1f} m/s")
        
        print(f"\nüìä MANEVRABILITE METRƒ∞KLERƒ∞:")
        print("-"*50)
        print(f"üéØ Tamamlanan Manevralar: {self.maneuver_count}")
        print(f"‚è±Ô∏è Toplam Manevrabilite S√ºresi: {self.total_maneuver_time}s")
        print(f"üìê Maksimum Roll A√ßƒ±sƒ±: {self.max_roll_angle:.1f}¬∞")
        print(f"üìê Maksimum Pitch A√ßƒ±sƒ±: {self.max_pitch_angle:.1f}¬∞")
        print(f"‚ö†Ô∏è Stabilite ƒ∞hlalleri: {self.stability_violations}")
        
        print(f"\nüìã MANEVRA DETAYLARI:")
        print("-"*50)
        
        total_success = 0
        for i, log_entry in enumerate(self.maneuver_log):
            maneuver = log_entry['maneuver']
            success = log_entry['success']
            duration = log_entry['duration']
            
            status_icon = "‚úÖ" if success else "‚ùå"
            maneuver_names = {
                'STRAIGHT_CRUISE': 'D√ºz Seyir',
                'TURN_RIGHT': 'Saƒü D√∂n√º≈ü',
                'TURN_LEFT': 'Sol D√∂n√º≈ü', 
                'PITCH_UP': 'Yukarƒ± Yunuslama',
                'PITCH_DOWN': 'A≈üaƒüƒ± Yunuslama',
                'SURFACE_ASCENT': 'Y√ºzeye √áƒ±kƒ±≈ü',
                'RETURN_TO_START': 'Ba≈ülangƒ±√ß D√∂n√º≈ü√º'
            }
            
            maneuver_name = maneuver_names.get(maneuver, maneuver)
            print(f"  {status_icon} {i+1}. {maneuver_name}: {duration}s - {'BA≈ûARILI' if success else 'BA≈ûARISIZ'}")
            
            if success:
                total_success += 1
        
        # ≈ûartname deƒüerlendirmesi
        print(f"\nüéØ ≈ûARTNAME GEREKSƒ∞Nƒ∞MLERƒ∞:")
        print("-"*40)
        
        time_ok = self.total_maneuver_time >= MIN_MANEUVER_TIME
        time_icon = "‚úÖ" if time_ok else "‚ùå"
        print(f"  {time_icon} Minimum Manevrabilite S√ºresi (‚â•{MIN_MANEUVER_TIME}s): {self.total_maneuver_time}s")
        
        stability_ok = self.stability_violations == 0
        stability_icon = "‚úÖ" if stability_ok else "‚ùå"
        print(f"  {stability_icon} Kontroll√º Hareket: {self.stability_violations} ihlal")
        
        maneuver_variety_ok = len(set([log['maneuver'] for log in self.maneuver_log])) >= 4
        variety_icon = "‚úÖ" if maneuver_variety_ok else "‚ùå"
        print(f"  {variety_icon} Manevra √áe≈üitliliƒüi: {len(set([log['maneuver'] for log in self.maneuver_log]))} farklƒ± tip")
        
        surface_ascent_ok = any(log['maneuver'] == 'SURFACE_ASCENT' and log['success'] for log in self.maneuver_log)
        surface_icon = "‚úÖ" if surface_ascent_ok else "‚ùå"
        print(f"  {surface_icon} Y√ºzeye √áƒ±kƒ±≈ü: {'BA≈ûARILI' if surface_ascent_ok else 'BA≈ûARISIZ'}")
        
        # Ba≈üarƒ± oranƒ±
        success_rate = (total_success / len(self.maneuver_log)) * 100 if self.maneuver_log else 0
        print(f"\nüìà Manevrabilite Ba≈üarƒ± Oranƒ±: {success_rate:.1f}% ({total_success}/{len(self.maneuver_log)})")
        
        # Final deƒüerlendirme
        overall_success = time_ok and stability_ok and maneuver_variety_ok and surface_ascent_ok and success_rate >= 70
        
        print(f"\nüèÜ GENEL SONU√á:")
        print("="*30)
        
        if overall_success:
            print("üéâ MANEVRABƒ∞Lƒ∞TE KABƒ∞Lƒ∞YETƒ∞ TAM BA≈ûARI!")
            print("üìπ Video √ßekimi i√ßin hazƒ±r!")
        else:
            print("‚ùå MANEVRABƒ∞Lƒ∞TE KABƒ∞Lƒ∞YETƒ∞ EKSƒ∞KLƒ∞KLER VAR!")
            print("üîß Sistem iyile≈ütirmeleri gerekli!")
        
        # Veri kaydet
        report_data = {
            'timestamp': datetime.now().isoformat(),
            'demo_duration': demo_duration,
            'total_maneuver_time': self.total_maneuver_time,
            'maneuver_count': self.maneuver_count,
            'stability_violations': self.stability_violations,
            'max_roll_angle': self.max_roll_angle,
            'max_pitch_angle': self.max_pitch_angle,
            'maneuver_results': self.maneuver_log,
            'telemetry_summary': {
                'max_depth': max([d['depth'] for d in self.telemetry_data], default=0),
                'max_speed': max([d['speed'] for d in self.telemetry_data], default=0),
                'total_samples': len(self.telemetry_data)
            },
            'overall_success': overall_success
        }
        
        with open(f'maneuver_demo_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json', 'w') as f:
            json.dump(report_data, f, indent=2)
        
        print(f"\nüíæ Demo raporu kaydedildi: maneuver_demo_report_*.json")
        
        return overall_success
    
    def run_full_maneuverability_demo(self):
        """Tam manevrabilite demo"""
        print("üé¨ TEKNOFEST Su Altƒ± Roket Aracƒ± - MANEVRABƒ∞Lƒ∞TE DEMOsu")
        print("="*70)
        print("üìπ Video √ßekimi i√ßin manevrabilite yetenekleri g√∂sterimi")
        print("‚è±Ô∏è Tahmini s√ºre: 6-8 dakika")
        print("üéØ ≈ûartname: ‚â•1 dakika kontroll√º manevralar, y√ºzeye √ßƒ±kƒ±≈ü")
        
        if not self.connect_pixhawk():
            print("‚ùå Pixhawk baƒülantƒ±sƒ± ba≈üarƒ±sƒ±z!")
            return False
        
        print("\n‚ö†Ô∏è G√úVENLƒ∞K UYARISI:")
        print("- Manevrabilite alanƒ± temiz ve g√ºvenli mi?")
        print("- Kameralar t√ºm a√ßƒ±larƒ± kaydediyor mu?")
        print("- Acil m√ºdahale ekibi hazƒ±r mƒ±?")
        
        ready = input("\n‚úÖ Manevrabilite demosu ba≈ülasƒ±n mƒ±? (y/n): ").lower()
        if ready != 'y':
            print("‚ùå Demo iptal edildi")
            return False
        
        self.demo_start_time = time.time()
        self.demo_active = True
        self.running = True
        
        # Start position kaydet
        self.start_position = (0.0, 0.0)
        self.position_x = 0.0
        self.position_y = 0.0
        
        # Monitoring thread ba≈ülat
        self.monitoring_thread = threading.Thread(target=self.monitoring_loop)
        self.monitoring_thread.daemon = True
        self.monitoring_thread.start()
        
        try:
            print("\nüöÄ MANEVRABƒ∞Lƒ∞TE DEMOsu BA≈ûLADI!")
            
            # 1. Demo derinliƒüine in
            self.demo_stage = "DESCENT"
            if not self.descend_to_demo_depth():
                print("‚ùå Demo derinliƒüine inilemedi!")
                return False
            
            input("\n‚è∏Ô∏è Derinlik tamam! Manevrabilite testlerine ba≈ülanacak. ENTER...")
            
            # 2. Manevrabilite testleri
            self.demo_stage = "MANEUVERS"
            
            # D√ºz seyir
            self.maneuver_straight_cruise(15)
            time.sleep(3)  # Stabilizasyon arasƒ±
            
            # Saƒü d√∂n√º≈ü
            self.maneuver_turn_right(12, 90)
            time.sleep(3)
            
            # Sol d√∂n√º≈ü
            self.maneuver_turn_left(12, 90)
            time.sleep(3)
            
            # Yukarƒ± yunuslama
            self.maneuver_pitch_up(10, 20)
            time.sleep(3)
            
            # A≈üaƒüƒ± yunuslama
            self.maneuver_pitch_down(10, -20)
            time.sleep(3)
            
            input("\n‚è∏Ô∏è Temel manevralar tamam! Y√ºzeye √ßƒ±kƒ±≈ü testine ge√ßilsin mi? ENTER...")
            
            # 3. Y√ºzeye √ßƒ±kƒ±≈ü testi
            self.demo_stage = "SURFACE_ASCENT"
            self.maneuver_surface_ascent(20)
            
            time.sleep(5)  # Y√ºzeyde bekle
            
            # 4. (Opsiyonel) Ba≈ülangƒ±√ß pozisyonuna d√∂n√º≈ü
            if input("\nüè† Ba≈ülangƒ±√ß pozisyonuna d√∂n√ºls√ºn m√º? (y/n): ").lower() == 'y':
                self.demo_stage = "RETURN_HOME"
                self.return_to_start_position(25)
            
            # 5. Demo raporu
            success = self.generate_demo_report()
            
            if success:
                print("\nüéâ MANEVRABƒ∞Lƒ∞TE DEMOsu BA≈ûARILI!")
                print("üìπ Video montaja hazƒ±r!")
            
            return success
            
        except KeyboardInterrupt:
            print("\n‚ö†Ô∏è Demo kullanƒ±cƒ± tarafƒ±ndan durduruldu")
            return False
        except Exception as e:
            print(f"\n‚ùå Demo hatasƒ±: {e}")
            return False
        finally:
            self.cleanup()
    
    def cleanup(self):
        """Temizlik i≈ülemleri"""
        self.demo_active = False
        self.running = False
        
        print("\nüßπ Sistem temizleniyor...")
        
        if self.connected:
            # Motorlarƒ± durdur
            self.set_motor_throttle(PWM_NEUTRAL)
            
            # Finleri n√∂tr pozisyon
            self.set_control_surfaces()
        
        if self.master:
            self.master.close()
            print("üîå MAVLink baƒülantƒ±sƒ± kapatƒ±ldƒ±")
        
        print("‚úÖ Sistem temizleme tamamlandƒ±")

def main():
    """Ana fonksiyon"""
    demo = ManeuverabilityDemo()
    
    try:
        success = demo.run_full_maneuverability_demo()
        return 0 if success else 1
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Program sonlandƒ±rƒ±ldƒ±")
        return 1

if __name__ == "__main__":
    import sys
    sys.exit(main()) 