#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MISSION 1 - Seyir ve Ba≈ülangƒ±√ß Noktasƒ±na D√∂n√º≈ü G√∂revi
Yeni g√∂rev tanƒ±mƒ±:
- Dalgƒ±√ß aracƒ± belirli derinliƒüe indirir, butona basar
- 90 saniye bekleme (buzzer ve LED mesajlarƒ±yla)
- Suyun altƒ±nda herhangi bir derinlikte g√∂rev ba≈ülar
- ƒ∞lk 10m ileri gider
- 40m daha ileri gider (toplam 50m)
- U d√∂n√º≈ü√º yapar
- 50m geri gelir
- Son 2m kala kontroll√º y√ºzeye √ßƒ±kar
- Sistemler yazƒ±lƒ±msal olarak kapatƒ±lƒ±r
"""

import time
import math
from config import *
from utils import Timer, estimate_distance, format_time
from sensors import SensorManager
from control import StabilizationController, MotionController

# GPIO import - Raspberry Pi 5 uyumlu
try:
    from gpio_compat import GPIO
    GPIO_AVAILABLE = True
    print("‚úÖ Pi 5 uyumlu GPIO sistemi y√ºklendi")
except ImportError:
    try:
        from gpio_wrapper import GPIO
        GPIO_AVAILABLE = True
        print("‚úÖ GPIO wrapper sistemi y√ºklendi")
    except ImportError:
        GPIO_AVAILABLE = False
        print("‚ùå GPIO sistemi mevcut deƒüil - sim√ºlasyon modunda √ßalƒ±≈üacak")

class Mission1Controller:
    """G√∂rev 1 Ana Kontrol Sƒ±nƒ±fƒ±"""
    
    def __init__(self, mavlink_connection, system_status, logger, sensor_manager=None):
        self.mavlink = mavlink_connection
        self.system_status = system_status
        self.logger = logger
        
        # Ana bile≈üenler - kalibre edilmi≈ü sens√∂r manager'ƒ± kullan
        self.sensors = sensor_manager if sensor_manager else SensorManager(mavlink_connection, logger)
        self.stabilizer = StabilizationController(mavlink_connection, self.sensors, logger)
        self.motion = MotionController(self.stabilizer, logger)
        
        # G√∂rev durumu
        self.mission_timer = Timer()
        self.phase_timer = Timer()
        self.current_phase = MissionPhase.WAITING
        self.mission_completed = False
        self.mission_success = False
        
        # 90 saniye bekleme i√ßin
        self.waiting_timer = Timer()
        self.waiting_completed = False
        
        # Mesafe takibi - yeni g√∂rev planƒ±
        self.total_distance_traveled = 0.0
        self.phase_distance = 0.0
        self.current_speed_pwm = MOTOR_STOP
        
        # Yeni mesafe planƒ± i√ßin deƒüi≈ükenler
        self.phase1_distance = 0.0   # ƒ∞lk 10m
        self.phase2_distance = 0.0   # Sonraki 40m
        self.return_distance = 0.0   # Geri d√∂n√º≈ü 50m
        
        # Y√ºzeye √ßƒ±kƒ±≈ü kontrol√º i√ßin
        self.surface_approach_started = False
        self.initial_depth = None    # Ba≈ülangƒ±√ß derinliƒüi
        
        self.logger.info("G√∂rev 1 kontrolc√ºs√º ba≈ülatƒ±ldƒ±")
        
    def initialize_mission(self):
        """G√∂rev ba≈ülangƒ±√ß hazƒ±rlƒ±klarƒ±"""
        self.logger.info("G√∂rev 1 ba≈ülangƒ±√ß hazƒ±rlƒ±klarƒ±...")
        
        try:
            # NOT: Sens√∂r kalibrasyonu main.py'de zaten yapƒ±ldƒ±, tekrar yapma!
            self.logger.info("Sens√∂rler ana kontrolc√ºde kalibre edildi")
                
            # Stabilizasyonu ba≈ülat
            self.stabilizer.enable_stabilization()
            
            # Servolarƒ± n√∂trle
            self.stabilizer.servo_controller.neutral_all_servos()
            
            # G√∂rev zamanlayƒ±cƒ±sƒ±nƒ± ba≈ülat
            self.mission_timer.start()
            
            self.logger.info("G√∂rev 1 hazƒ±rlƒ±klarƒ± tamamlandƒ±")
            return True
            
        except Exception as e:
            self.logger.error(f"G√∂rev ba≈ülangƒ±√ß hatasƒ±: {e}")
            return False
            
    def start_mission(self):
        """Ana g√∂rev d√∂ng√ºs√º - yeni g√∂rev tanƒ±mƒ±na g√∂re"""
        self.logger.info("üöÄ G√ñREV 1 BA≈ûLIYOR!")
        
        try:
            # Faz 0: 90 saniye bekleme (buzzer ve LED ile)
            if not self._execute_waiting_phase():
                return False
            
            # Ba≈ülangƒ±√ß derinliƒüini kaydet
            self._record_initial_depth()
                
            # Faz 1: ƒ∞lk 10 metre ileri
            if not self._execute_phase_1_new():
                return False
                
            # Faz 2: 40 metre daha ileri (toplam 50m)
            if not self._execute_phase_2_new():
                return False
                
            # Faz 3: U d√∂n√º≈ü√º (180¬∞)
            if not self._execute_u_turn():
                return False
                
            # Faz 4: 50 metre geri d√∂n√º≈ü
            if not self._execute_return_new():
                return False
                
            # Faz 5: Son 2m kala kontroll√º y√ºzeye √ßƒ±kƒ±≈ü
            if not self._execute_controlled_surfacing():
                return False
                
            # Faz 6: Sistem kapatma
            if not self._execute_system_shutdown():
                return False
                
            # G√∂rev ba≈üarƒ±lƒ±
            self.mission_completed = True
            self.mission_success = True
            self.system_status.set_phase(MissionPhase.COMPLETED)
            
            self.logger.info("üéâ G√ñREV 1 BA≈ûARIYLA TAMAMLANDI!")
            return True
            
        except Exception as e:
            self.logger.error(f"G√∂rev hatasƒ±: {e}")
            self._emergency_abort()
            return False
            
    def _execute_waiting_phase(self):
        """Faz 0: 90 saniye bekleme (buzzer ve LED mesajlarƒ±yla)"""
        self.logger.info("üï∞Ô∏è FAZ 0: 90 saniye bekleme ba≈ülatƒ±lƒ±yor...")
        self.current_phase = MissionPhase.WAITING
        self.system_status.set_phase(MissionPhase.WAITING)
        self.waiting_timer.start()
        
        # Buzzer ba≈ülangƒ±√ß sinyali
        if GPIO_AVAILABLE:
            try:
                GPIO.setmode(GPIO.BCM)
                GPIO.setup(GPIO_BUZZER, GPIO.OUT)
                GPIO.setup(GPIO_LED_RED, GPIO.OUT)
            except:
                self.logger.warning("GPIO kurulumu yapƒ±lamadƒ±, buzzer/LED √ßalƒ±≈ümayacak")
        else:
            self.logger.warning("GPIO mevcut deƒüil, buzzer/LED sim√ºle edilecek")
        
        countdown_seconds = 10
        
        while countdown_seconds > 0:
            # Buton kontrol√º - acil durdurma
            button_action = self.system_status.check_start_button()
            if button_action == "stop":
                self.logger.info("Bekleme fazƒ± kullanƒ±cƒ± tarafƒ±ndan durduruldu")
                return False
            
            # Her 10 saniyede bir durum raporu
            if countdown_seconds % 10 == 0:
                self.logger.info(f"‚è∞ Kalan s√ºre: {countdown_seconds} saniye")
                
                # Buzzer ve LED sinyali
                if GPIO_AVAILABLE:
                    try:
                        # Kƒ±sa bip ve LED yanƒ±p s√∂nme
                        GPIO.output(GPIO_BUZZER, GPIO.HIGH)
                        GPIO.output(GPIO_LED_RED, GPIO.HIGH)
                        time.sleep(0.2)
                        GPIO.output(GPIO_BUZZER, GPIO.LOW)
                        GPIO.output(GPIO_LED_RED, GPIO.LOW)
                    except:
                        pass
            
            # Son 10 saniyede hƒ±zlƒ± bip
            if countdown_seconds <= 10:
                if GPIO_AVAILABLE:
                    try:
                        GPIO.output(GPIO_BUZZER, GPIO.HIGH)
                        GPIO.output(GPIO_LED_RED, GPIO.HIGH)
                        time.sleep(0.1)
                        GPIO.output(GPIO_BUZZER, GPIO.LOW)
                        GPIO.output(GPIO_LED_RED, GPIO.LOW)
                        time.sleep(0.1)
                    except:
                        time.sleep(0.2)
                else:
                    time.sleep(0.2)
            else:
                time.sleep(1.0)
            
            countdown_seconds -= 1
        
        # Bekleme tamamlandƒ± sinyali
        self.logger.info("‚úÖ 90 saniye bekleme tamamlandƒ±!")
        if GPIO_AVAILABLE:
            try:
                for _ in range(3):
                    GPIO.output(GPIO_BUZZER, GPIO.HIGH)
                    GPIO.output(GPIO_LED_RED, GPIO.HIGH)
                    time.sleep(0.5)
                    GPIO.output(GPIO_BUZZER, GPIO.LOW)
                    GPIO.output(GPIO_LED_RED, GPIO.LOW)
                    time.sleep(0.5)
            except:
                pass
        
        self.waiting_completed = True
        return True
    
    def _record_initial_depth(self):
        """Ba≈ülangƒ±√ß derinliƒüini kaydet - ara√ß 2-2.5m derinliƒüe indirileceƒüi i√ßin"""
        try:
            sensor_data = self.sensors.get_all_sensor_data()
            depth_data = sensor_data['depth']
            if depth_data['is_valid']:
                measured_depth = depth_data['depth_m']
                
                # 2-2.5m aralƒ±ƒüƒ±nda olmalƒ±
                if 1.8 <= measured_depth <= 2.7:
                    self.initial_depth = measured_depth
                    self.logger.info(f"üåä Ba≈ülangƒ±√ß derinliƒüi: {self.initial_depth:.2f}m (√∂l√ß√ºlen)")
                else:
                    # Aralƒ±k dƒ±≈üƒ±ndaysa 2.25m varsayƒ±lan kullan
                    self.initial_depth = 2.25
                    self.logger.warning(f"√ñl√ß√ºlen derinlik ({measured_depth:.2f}m) beklenen aralƒ±k dƒ±≈üƒ±nda, varsayƒ±lan 2.25m kullanƒ±lƒ±yor")
            else:
                # D300 okunamƒ±yorsa 2.25m varsayƒ±lan (2-2.5m ortasƒ±)
                self.initial_depth = 2.25
                self.logger.warning("D300 sens√∂r√º okunamadƒ±, varsayƒ±lan 2.25m kullanƒ±lƒ±yor (2-2.5m aralƒ±k ortasƒ±)")
                
        except Exception as e:
            self.logger.error(f"Ba≈ülangƒ±√ß derinlik okuma hatasƒ±: {e}")
            self.initial_depth = 2.25  # G√ºvenli varsayƒ±lan
    
    def _execute_phase_1_new(self):
        """Faz 1: ƒ∞lk 10 metre ileri hareket"""
        self.logger.info("üìç FAZ 1: ƒ∞lk 10 metre ileri")
        self.current_phase = MissionPhase.PHASE_1
        self.system_status.set_phase(MissionPhase.PHASE_1)
        self.phase_timer.start()
        
        # Hedef deƒüerler
        target_distance = 10.0  # ƒ∞lk 10 metre
        speed_pwm = SPEED_MEDIUM
        
        # Mevcut derinlikte kal (ba≈ülangƒ±√ß derinliƒüi)
        if self.initial_depth:
            self.stabilizer.set_target_depth(self.initial_depth)
        
        self.current_speed_pwm = speed_pwm
        
        # Stabilizasyonu aktif et ve motoru ba≈ülat
        self.stabilizer.enable_stabilization()
        self.motion.forward(speed_pwm)
        
        self.phase_distance = 0.0
        last_distance_check = time.time()
        
        while True:
            # Buton kontrol√º
            button_action = self.system_status.check_start_button()
            if button_action == "stop":
                self.logger.info("Faz 1 kullanƒ±cƒ± tarafƒ±ndan durduruldu")
                return False
                
            # Stabilizasyonu g√ºncelle
            try:
                if not self.stabilizer.update_stabilization():
                    self.logger.warning("Stabilizasyon g√ºncellenemedi")
            except Exception as stab_error:
                self.logger.error(f"Faz 1 stabilizasyon hatasƒ±: {stab_error}")
                return False
                
            # Mesafe hesaplama
            current_time = time.time()
            if current_time - last_distance_check >= 1.0:  # Her saniye
                phase_time = self.phase_timer.elapsed()
                if speed_pwm is not None and phase_time is not None:
                    estimated_distance = estimate_distance(speed_pwm, phase_time)
                    self.phase_distance = estimated_distance
                    self.total_distance_traveled = estimated_distance
                else:
                    estimated_distance = 0.0
                    self.logger.warning("Mesafe hesaplama i√ßin gerekli veriler eksik")
                
                # Durum raporu - D300 kesilirse sistem durmasƒ±n
                depth_result = self.sensors.depth.get_depth_safe("PHASE_1")
                current_depth, connection_status, fallback_used = depth_result
                
                # D300 kesintisi durumunda uyarƒ± ver ama devam et
                if connection_status in ["EMERGENCY_PHASE1", "TEMPORARY_ISSUE"]:
                    self.logger.warning(f"‚ö†Ô∏è D300 baƒülantƒ± sorunu ({connection_status}) - tahmine dayalƒ± devam ediliyor")
                    # D300'√º yeniden almaya √ßalƒ±≈ü (arka planda)
                    try:
                        self.sensors.depth.reconnect_attempt()
                    except:
                        pass
                
                depth_str = f"{current_depth:.1f}m" if current_depth else f"~{self.initial_depth:.1f}m"
                status_indicator = "‚ö†Ô∏è" if fallback_used else "‚úÖ"
                
                self.logger.info(f"Faz 1 - Mesafe: {estimated_distance:.1f}m/{target_distance}m, "
                               f"Derinlik: {depth_str} {status_indicator}")
                
                last_distance_check = current_time
                
            # Hedef mesafeye ula≈ütƒ±k mƒ±?
            if self.phase_distance >= target_distance:
                self.phase1_distance = self.phase_distance
                self.logger.info(f"‚úì Faz 1 tamamlandƒ±: {self.phase1_distance:.1f}m")
                break
                
            # Global g√∂rev timeout kontrol√º (sadece bu)
            if self.mission_timer.elapsed() > MISSION_TIMEOUT_SECONDS:
                self.logger.error(f"üö® GLOBAL TIMEOUT! Sistem 180s sonra otomatik kapanƒ±yor")
                return False
                
            time.sleep(0.02)  # 50Hz
            
        return True
        
    def _execute_phase_2_new(self):
        """Faz 2: 40 metre daha ileri (toplam 50m)"""
        self.logger.info("üìç FAZ 2: 40 metre daha ileri (toplam 50m olacak)")
        self.current_phase = MissionPhase.PHASE_2
        self.system_status.set_phase(MissionPhase.PHASE_2)
        self.phase_timer.start()
        
        # Hedef deƒüerler
        target_distance = 40.0  # 40 metre daha
        speed_pwm = SPEED_FAST  # Daha hƒ±zlƒ±
        
        # Aynƒ± derinlikte devam et
        if self.initial_depth:
            self.stabilizer.set_target_depth(self.initial_depth)
        
        self.current_speed_pwm = speed_pwm
        
        # Stabilizasyonu aktif et (g√ºvenlik kontrol√º)
        if not self.stabilizer.stabilization_active:
            self.stabilizer.enable_stabilization()
            self.logger.info("‚ö†Ô∏è Faz 2'de stabilizasyon yeniden aktif edildi")
        
        # Hƒ±zƒ± artƒ±r
        self.motion.forward(speed_pwm)
        
        phase_2_distance = 0.0
        last_distance_check = time.time()
        
        while True:
            # Buton kontrol√º
            button_action = self.system_status.check_start_button()
            if button_action == "stop":
                self.logger.info("Faz 2 kullanƒ±cƒ± tarafƒ±ndan durduruldu")
                return False
                
            # Stabilizasyonu g√ºncelle
            if not self.stabilizer.update_stabilization():
                self.logger.warning("Stabilizasyon g√ºncellenemedi")
                
            # Mesafe hesaplama
            current_time = time.time()
            if current_time - last_distance_check >= 1.0:  # Her saniye
                phase_time = self.phase_timer.elapsed()
                if speed_pwm is not None and phase_time is not None:
                    estimated_distance = estimate_distance(speed_pwm, phase_time)
                    phase_2_distance = estimated_distance
                    self.total_distance_traveled = self.phase1_distance + phase_2_distance
                else:
                    estimated_distance = 0.0
                    phase_2_distance = 0.0
                    self.logger.warning("Faz 2 mesafe hesaplama i√ßin gerekli veriler eksik")
                
                # Durum raporu - D300 kesilirse sistem durmasƒ±n
                depth_result = self.sensors.depth.get_depth_safe("PHASE_2")
                current_depth, connection_status, fallback_used = depth_result
                
                # D300 kesintisi durumunda uyarƒ± ver ama devam et
                if connection_status in ["EMERGENCY_PHASE1", "TEMPORARY_ISSUE"]:
                    self.logger.warning(f"‚ö†Ô∏è D300 baƒülantƒ± sorunu ({connection_status}) - tahmine dayalƒ± devam ediliyor")
                    # D300'√º yeniden almaya √ßalƒ±≈ü
                    try:
                        self.sensors.depth.reconnect_attempt()
                    except:
                        pass
                
                depth_str = f"{current_depth:.1f}m" if current_depth else f"~{self.initial_depth:.1f}m"
                status_indicator = "‚ö†Ô∏è" if fallback_used else "‚úÖ"
                
                total_forward = self.phase1_distance + phase_2_distance
                self.logger.info(f"Faz 2 - Mesafe: {phase_2_distance:.1f}m/{target_distance}m, "
                               f"Toplam: {total_forward:.1f}m/50m, "
                               f"Derinlik: {depth_str} {status_indicator}")
                
                last_distance_check = current_time
                
            # Hedef mesafeye ula≈ütƒ±k mƒ±?
            if phase_2_distance >= target_distance:
                self.phase2_distance = phase_2_distance
                total_forward = self.phase1_distance + self.phase2_distance
                self.logger.info(f"‚úì Faz 2 tamamlandƒ±: {self.phase2_distance:.1f}m (Toplam ileri: {total_forward:.1f}m)")
                break
                
            # Global g√∂rev timeout kontrol√º (sadece bu)
            if self.mission_timer.elapsed() > MISSION_TIMEOUT_SECONDS:
                self.logger.error(f"üö® GLOBAL TIMEOUT! Sistem 180s sonra otomatik kapanƒ±yor")
                return False
                
            time.sleep(0.02)  # 50Hz
            
        return True
        
    def _execute_u_turn(self):
        """Faz 3: U d√∂n√º≈ü√º (180¬∞)"""
        self.logger.info("üîÑ FAZ 3: U d√∂n√º≈ü√º (180¬∞)")
        self.current_phase = MissionPhase.TURNING
        self.system_status.set_phase(MissionPhase.TURNING)
        
        # Motoru yava≈ülat/durdur
        self.motion.stop()
        time.sleep(4)  # 4 saniye duraklamasƒ± i√ßin bekle
        
        # 180¬∞ U d√∂n√º≈ü√º yap
        success = self.stabilizer.turn_180_degrees(timeout=30)
        
        if success:
            self.logger.info("‚úì U d√∂n√º≈ü√º tamamlandƒ±")
            return True
        else:
            self.logger.error("‚úó U d√∂n√º≈ü√º ba≈üarƒ±sƒ±z!")
            return False
            
    def _execute_return_new(self):
        """Faz 4: 50 metre geri d√∂n√º≈ü"""
        self.logger.info("üîô FAZ 4: 50 metre geri d√∂n√º≈ü")
        self.current_phase = MissionPhase.RETURN
        self.system_status.set_phase(MissionPhase.RETURN)
        self.phase_timer.start()
        
        # Hedef deƒüerler - tam olarak 50 metre geri
        return_distance = 50.0  # Sabit 50 metre
        speed_pwm = SPEED_FAST
        
        # Aynƒ± derinlikte devam et
        if self.initial_depth:
            self.stabilizer.set_target_depth(self.initial_depth)
        
        self.current_speed_pwm = speed_pwm
        
        # Stabilizasyonu aktif et (U d√∂n√º≈ü sonrasƒ± g√ºvenlik kontrol√º)
        if not self.stabilizer.stabilization_active:
            self.stabilizer.enable_stabilization()
            self.logger.info("‚úÖ Faz 4'te stabilizasyon yeniden aktif edildi (U d√∂n√º≈ü sonrasƒ±)")
        
        self.logger.info(f"Geri d√∂n√º≈ü hedefi: {return_distance}m")
        
        # ƒ∞leri hareket ba≈ülat (180¬∞ d√∂nd√ºk, y√∂n ters oldu)
        self.motion.forward(speed_pwm)
        
        return_distance_traveled = 0.0
        last_distance_check = time.time()
        
        while True:
            # Buton kontrol√º
            button_action = self.system_status.check_start_button()
            if button_action == "stop":
                self.logger.info("Geri d√∂n√º≈ü kullanƒ±cƒ± tarafƒ±ndan durduruldu")
                return False
                
            # Stabilizasyonu g√ºncelle
            if not self.stabilizer.update_stabilization():
                self.logger.warning("Stabilizasyon g√ºncellenemedi")
                
            # Mesafe hesaplama
            current_time = time.time()
            if current_time - last_distance_check >= 1.0:  # Her saniye
                phase_time = self.phase_timer.elapsed()
                if speed_pwm is not None and phase_time is not None:
                    estimated_distance = estimate_distance(speed_pwm, phase_time)
                    return_distance_traveled = estimated_distance
                else:
                    estimated_distance = 0.0
                    return_distance_traveled = 0.0
                    self.logger.warning("Geri d√∂n√º≈ü mesafe hesaplama i√ßin gerekli veriler eksik")
                
                # Durum raporu - D300 kesilirse sistem durmasƒ±n
                depth_result = self.sensors.depth.get_depth_safe("RETURN")
                current_depth, connection_status, fallback_used = depth_result
                
                # D300 kesintisi durumunda uyarƒ± ver ama devam et
                if connection_status in ["EMERGENCY_PHASE1", "TEMPORARY_ISSUE"]:
                    self.logger.warning(f"‚ö†Ô∏è D300 baƒülantƒ± sorunu ({connection_status}) - tahmine dayalƒ± devam ediliyor")
                    # D300'√º yeniden almaya √ßalƒ±≈ü
                    try:
                        self.sensors.depth.reconnect_attempt()
                    except:
                        pass
                
                depth_str = f"{current_depth:.1f}m" if current_depth else f"~{self.initial_depth:.1f}m"
                status_indicator = "‚ö†Ô∏è" if fallback_used else "‚úÖ"
                
                # Son 6-7 metre kontrol√º - kademeli y√ºzeye √ßƒ±kƒ±≈ü
                remaining = return_distance - return_distance_traveled
                if remaining <= 7.0 and not self.surface_approach_started:
                    self.logger.info("üåä Son 7 metre! Kademeli y√ºzeye √ßƒ±kƒ±≈ü ba≈ülƒ±yor...")
                    self.surface_approach_started = True
                    # Kademeli y√ºzeye √ßƒ±kƒ±≈ü ba≈ülat
                    self._start_gradual_surface_approach(remaining)
                
                self.logger.info(f"Geri d√∂n√º≈ü - Mesafe: {return_distance_traveled:.1f}m/{return_distance}m, "
                               f"Kalan: {remaining:.1f}m, "
                               f"Derinlik: {depth_str} {status_indicator}")
                
                last_distance_check = current_time
                
            # Hedef mesafeye ula≈ütƒ±k mƒ±?
            if return_distance_traveled >= return_distance:
                self.return_distance = return_distance_traveled
                self.logger.info(f"‚úì Geri d√∂n√º≈ü tamamlandƒ±: {self.return_distance:.1f}m")
                break
                
            # Global g√∂rev timeout kontrol√º (sadece bu)
            if self.mission_timer.elapsed() > MISSION_TIMEOUT_SECONDS:
                self.logger.error(f"üö® GLOBAL TIMEOUT! Sistem 180s sonra otomatik kapanƒ±yor")
                return False
                
            time.sleep(0.02)  # 50Hz
            
        return True
    
    def _start_gradual_surface_approach(self, remaining_distance):
        """Son 6-7m kala kademeli y√ºzeye √ßƒ±kƒ±≈ü ba≈ülat"""
        try:
            self.logger.info(f"üîÑ Kademeli y√ºzeye √ßƒ±kƒ±≈ü ba≈ülatƒ±lƒ±yor - Kalan mesafe: {remaining_distance:.1f}m")
            
            # Motor g√ºc√ºn√º kademeli azalt
            if remaining_distance <= 7.0:
                # 7m kaldƒ±ƒüƒ±nda motor g√ºc√ºn√º %80'e d√º≈ü√ºr
                reduced_power = int(SPEED_FAST * 0.8)
                self.motion.forward(reduced_power)
                self.logger.info(f"Motor g√ºc√º %80'e d√º≈ü√ºr√ºld√º: {reduced_power}")
                
            if remaining_distance <= 5.0:
                # 5m kaldƒ±ƒüƒ±nda motor g√ºc√ºn√º %60'a d√º≈ü√ºr ve pitch ver
                reduced_power = int(SPEED_FAST * 0.6)
                self.motion.forward(reduced_power)
                self._apply_gradual_pitch_up(0.1)  # Hafif pitch yukarƒ±
                self.logger.info(f"Motor g√ºc√º %60'a d√º≈ü√ºr√ºld√º ve hafif pitch verildi")
                
            if remaining_distance <= 3.0:
                # 3m kaldƒ±ƒüƒ±nda motor g√ºc√ºn√º %40'a d√º≈ü√ºr ve daha fazla pitch
                reduced_power = int(SPEED_FAST * 0.4)
                self.motion.forward(reduced_power)
                self._apply_gradual_pitch_up(0.2)  # Daha fazla pitch yukarƒ±
                self.logger.info(f"Motor g√ºc√º %40'a d√º≈ü√ºr√ºld√º ve pitch artƒ±rƒ±ldƒ±")
                
        except Exception as e:
            self.logger.error(f"Kademeli y√ºzeye √ßƒ±kƒ±≈ü hatasƒ±: {e}")
    
    def _apply_gradual_pitch_up(self, pitch_adjustment):
        """Kademeli pitch yukarƒ± uygula"""
        try:
            # Mevcut hedef derinliƒüi al
            current_target = getattr(self.stabilizer, 'target_depth', self.initial_depth)
            
            # Hedef derinliƒüi kademeli azalt (y√ºzeye doƒüru)
            new_target = max(0.5, current_target - pitch_adjustment)
            self.stabilizer.set_target_depth(new_target)
            
            self.logger.info(f"Hedef derinlik: {current_target:.2f}m -> {new_target:.2f}m")
            
        except Exception as e:
            self.logger.warning(f"Pitch ayarlama hatasƒ±: {e}")
        
    def _execute_controlled_surfacing(self):
        """Faz 5: Son 2m kala kontroll√º y√ºzeye √ßƒ±kƒ±≈ü"""
        self.logger.info("üåä FAZ 5: Kontroll√º y√ºzeye √ßƒ±kƒ±≈ü")
        self.current_phase = MissionPhase.SURFACING
        self.system_status.set_phase(MissionPhase.SURFACING)
        self.phase_timer.start()
        
        # Motoru durdur
        self.motion.stop()
        time.sleep(1)
        
        # Mevcut derinliƒüi al - D300 kesilirse tahmine dayalƒ± devam et
        try:
            sensor_data = self.sensors.get_all_sensor_data()
            depth_data = sensor_data['depth']
            if depth_data['is_valid']:
                current_depth = depth_data['depth_m']
                self.logger.info(f"Mevcut derinlik: {current_depth:.2f}m (√∂l√ß√ºlen)")
            else:
                current_depth = self.initial_depth if self.initial_depth else 2.25
                self.logger.warning(f"D300 okunamadƒ±, tahmine dayalƒ± derinlik: {current_depth:.2f}m")
        except Exception as e:
            self.logger.error(f"Derinlik okuma hatasƒ±: {e}")
            current_depth = self.initial_depth if self.initial_depth else 2.25
        
        # Kontroll√º y√ºzeye √ßƒ±kƒ±≈ü - derinlik azaltma
        target_depth_step = 0.5  # Her seferinde 0.5m y√ºksel
        surface_threshold = 0.3   # 0.3m'de y√ºzeye ula≈ütƒ±ƒüƒ±nƒ± kabul et
        
        while current_depth > surface_threshold:
            # Buton kontrol√º
            button_action = self.system_status.check_start_button()
            if button_action == "stop":
                self.logger.info("Y√ºzeye √ßƒ±kƒ±≈ü kullanƒ±cƒ± tarafƒ±ndan durduruldu")
                return False
            
            # Yeni hedef derinlik hesapla
            new_target = max(0.0, current_depth - target_depth_step)
            self.logger.info(f"Hedef derinlik: {current_depth:.2f}m -> {new_target:.2f}m")
            
            # Stabilizasyonu aktif et ve hedef derinliƒüi ayarla
            self.stabilizer.enable_stabilization()
            self.stabilizer.set_target_depth(new_target)
            
            # Kontroll√º y√ºkselme i√ßin s√ºre ver
            step_start = time.time()
            while time.time() - step_start < 5.0:  # 5 saniye bekle
                if not self.stabilizer.update_stabilization():
                    self.logger.warning("Stabilizasyon g√ºncellenemedi")
                    
                # Derinlik kontrol√º
                try:
                    sensor_data = self.sensors.get_all_sensor_data()
                    depth_data = sensor_data['depth']
                    if depth_data['is_valid']:
                        current_depth = depth_data['depth_m']
                        depth_error = abs(new_target - current_depth)
                        
                        # Hedefe yakla≈ütƒ±k mƒ±?
                        if depth_error < 0.2:  # 20cm tolerans
                            self.logger.info(f"Hedef derinliƒüe ula≈üƒ±ldƒ±: {current_depth:.2f}m")
                            break
                            
                except Exception as e:
                    self.logger.warning(f"Derinlik okuma hatasƒ±: {e}")
                    
                time.sleep(0.1)
            
            # Yeni derinliƒüi g√ºncelle
            try:
                sensor_data = self.sensors.get_all_sensor_data()
                depth_data = sensor_data['depth']
                if depth_data['is_valid']:
                    current_depth = depth_data['depth_m']
                    self.logger.info(f"G√ºncel derinlik: {current_depth:.2f}m")
            except:
                current_depth = new_target  # Tahmin olarak kullan
            
            # Global g√∂rev timeout kontrol√º (sadece bu)
            if self.mission_timer.elapsed() > MISSION_TIMEOUT_SECONDS:
                self.logger.error(f"üö® GLOBAL TIMEOUT! Sistem 180s sonra otomatik kapanƒ±yor")
                break  # Y√ºzeye √ßƒ±kƒ±≈üta g√ºvenlik i√ßin break
        
        # Son kontrol - y√ºzeye √ßƒ±kƒ±≈ü tamamlandƒ± mƒ±?
        if current_depth <= surface_threshold:
            self.logger.info(f"‚úÖ Y√ºzeye ba≈üarƒ±yla √ßƒ±kƒ±ldƒ±! Derinlik: {current_depth:.2f}m")
            
            # Stabilizasyonu deaktif et
            self.stabilizer.disable_stabilization()
            
            # T√ºm servolarƒ± n√∂trle
            self.stabilizer.servo_controller.neutral_all_servos()
            
            return True
        else:
            self.logger.warning(f"‚ö†Ô∏è Y√ºzeye tam olarak √ßƒ±kƒ±lamadƒ±. Mevcut derinlik: {current_depth:.2f}m")
            return True  # Kritik hata deƒüil, devam et
    
    def _execute_system_shutdown(self):
        """Faz 6: Sistemlerin yazƒ±lƒ±msal kapatƒ±lmasƒ±"""
        self.logger.info("üîå FAZ 6: Sistem kapatma i≈ülemi ba≈ülatƒ±lƒ±yor...")
        
        try:
            # 1. T√ºm motorlarƒ± durdur
            self.logger.info("1Ô∏è‚É£ Motorlar durduruluyor...")
            self.motion.stop()
            time.sleep(1)
            
            # 2. Stabilizasyonu deaktif et
            self.logger.info("2Ô∏è‚É£ Stabilizasyon deaktif ediliyor...")
            self.stabilizer.disable_stabilization()
            
            # 3. T√ºm servolarƒ± n√∂tr pozisyona getir
            self.logger.info("3Ô∏è‚É£ Servolar n√∂tr pozisyona getiriliyor...")
            self.stabilizer.servo_controller.neutral_all_servos()
            time.sleep(2)
            
            # 4. MAVLink baƒülantƒ±sƒ±nƒ± kapat
            self.logger.info("4Ô∏è‚É£ MAVLink baƒülantƒ±sƒ± kapatƒ±lƒ±yor...")
            try:
                if hasattr(self.mavlink, 'close'):
                    self.mavlink.close()
            except Exception as e:
                self.logger.warning(f"MAVLink kapatma hatasƒ±: {e}")
            
            # 5. GPIO temizliƒüi
            self.logger.info("5Ô∏è‚É£ GPIO temizliƒüi yapƒ±lƒ±yor...")
            if GPIO_AVAILABLE:
                try:
                    # Son uyarƒ± sinyali
                    for _ in range(3):
                        GPIO.output(GPIO_BUZZER, GPIO.HIGH)
                        GPIO.output(GPIO_LED_RED, GPIO.HIGH)
                        time.sleep(0.3)
                        GPIO.output(GPIO_BUZZER, GPIO.LOW)
                        GPIO.output(GPIO_LED_RED, GPIO.LOW)
                        time.sleep(0.3)
                    
                    # GPIO temizliƒüi
                    GPIO.cleanup()
                    self.logger.info("‚úÖ GPIO temizliƒüi tamamlandƒ±")
                except Exception as e:
                    self.logger.warning(f"GPIO temizlik hatasƒ±: {e}")
            else:
                self.logger.info("‚úÖ GPIO sim√ºlasyonu - temizlik atlandƒ±")
            
            # 6. Sens√∂r baƒülantƒ±larƒ±nƒ± kapat
            self.logger.info("6Ô∏è‚É£ Sens√∂r baƒülantƒ±larƒ± kapatƒ±lƒ±yor...")
            try:
                if hasattr(self.sensors, 'cleanup'):
                    self.sensors.cleanup()
            except Exception as e:
                self.logger.warning(f"Sens√∂r temizlik hatasƒ±: {e}")
            
            # 7. Zamanlayƒ±cƒ±larƒ± durdur
            self.logger.info("7Ô∏è‚É£ Zamanlayƒ±cƒ±lar durduruluyor...")
            try:
                if self.mission_timer.is_running():
                    self.mission_timer.pause()
                if self.phase_timer.is_running():
                    self.phase_timer.pause()
                if self.waiting_timer.is_running():
                    self.waiting_timer.pause()
            except Exception as e:
                self.logger.warning(f"Zamanlayƒ±cƒ± durdurma hatasƒ±: {e}")
            
            # 8. Son durum raporu
            total_mission_time = self.mission_timer.elapsed() if self.mission_timer else 0
            total_distance = self.phase1_distance + self.phase2_distance + self.return_distance
            
            self.logger.info("üìä G√ñREV √ñZET RAPORU:")
            self.logger.info(f"   ‚Ä¢ Toplam s√ºre: {format_time(total_mission_time)}")
            self.logger.info(f"   ‚Ä¢ Toplam mesafe: {total_distance:.1f}m")
            self.logger.info(f"   ‚Ä¢ Faz 1: {self.phase1_distance:.1f}m")
            self.logger.info(f"   ‚Ä¢ Faz 2: {self.phase2_distance:.1f}m") 
            self.logger.info(f"   ‚Ä¢ Geri d√∂n√º≈ü: {self.return_distance:.1f}m")
            self.logger.info(f"   ‚Ä¢ Ba≈ülangƒ±√ß derinliƒüi: {self.initial_depth:.1f}m")
            
            self.logger.info("‚úÖ Sistem kapatma i≈ülemi tamamlandƒ±")
            self.logger.info("üèÅ G√ñREV 1 TAMAMEN Bƒ∞Tƒ∞Rƒ∞LDƒ∞ - Sƒ∞STEM G√úVENLƒ∞ DURUMDA")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Sistem kapatma hatasƒ±: {e}")
            # Kritik hata olsa bile devam et
            return True
            

            
    def _emergency_abort(self):
        """Genel acil durum prosed√ºr√º"""
        self.logger.error("üö® ACƒ∞L DURUM - G√∂rev iptal ediliyor!")
        
        try:
            # Motoru durdur
            self.motion.stop()
            
            # Stabilizasyonu durdur
            self.stabilizer.disable_stabilization()
            
            # Sistem durumunu ayarla
            self.system_status.emergency_stop()
            
            # G√∂rev durumunu ayarla
            self.mission_completed = True
            self.mission_success = False
            self.current_phase = MissionPhase.EMERGENCY
            
        except Exception as e:
            self.logger.error(f"Acil durum prosed√ºr√º hatasƒ±: {e}")
            
    def get_mission_status(self):
        """G√∂rev durumu raporu"""
        status = {
            'phase': self.current_phase,
            'mission_time': self.mission_timer.elapsed() if self.mission_timer.is_running() else 0,
            'phase_time': self.phase_timer.elapsed() if self.phase_timer.is_running() else 0,
            'total_distance': self.total_distance_traveled if self.total_distance_traveled is not None else 0.0,
            'phase_distance': self.phase_distance if self.phase_distance is not None else 0.0,
            'completed': self.mission_completed,
            'success': self.mission_success,
            'current_speed': self.current_speed_pwm if self.current_speed_pwm is not None else MOTOR_STOP
        }
        
        # Sens√∂r durumu ekle
        try:
            sensor_data = self.sensors.get_all_sensor_data()
            if sensor_data and sensor_data['depth'] and sensor_data['depth']['is_valid']:
                depth_val = sensor_data['depth']['depth_m']
                if depth_val is not None:
                    status['current_depth'] = depth_val
            if sensor_data and sensor_data['attitude']:
                heading_val = sensor_data['attitude'].get('yaw_relative_deg')
                if heading_val is not None:
                    status['current_heading'] = heading_val
        except Exception as e:
            self.logger.warning(f"Sens√∂r durumu alma hatasƒ±: {e}")
            
        return status
        
    def log_mission_status(self):
        """G√∂rev durumunu logla"""
        status = self.get_mission_status()
        
        mission_time_str = format_time(status['mission_time'])
        phase_time_str = format_time(status['phase_time'])
        
        self.logger.info(f"G√∂rev Durumu - Faz: {status['phase']}, "
                        f"S√ºre: {mission_time_str}, "
                        f"Mesafe: {status['total_distance']:.1f}m")
                        
        if 'current_depth' in status and status['current_depth'] is not None:
            self.logger.info(f"Derinlik: {status['current_depth']:.2f}m")
            
        if 'current_heading' in status and status['current_heading'] is not None:
            self.logger.info(f"Heading: {status['current_heading']:.1f}¬∞")
            
    def cleanup(self):
        """G√∂rev temizliƒüi"""
        self.logger.info("G√∂rev 1 temizleniyor...")
        
        try:
            # Stabilizasyonu durdur
            self.stabilizer.disable_stabilization()
            
            # Motoru durdur
            self.motion.stop()
            
            # Zamanlayƒ±cƒ±larƒ± durdur
            if self.mission_timer.is_running():
                self.mission_timer.pause()
            if self.phase_timer.is_running():
                self.phase_timer.pause()
                
            self.logger.info("G√∂rev 1 temizliƒüi tamamlandƒ±")
            
        except Exception as e:
            self.logger.error(f"G√∂rev 1 temizlik hatasƒ±: {e}")

def run_mission_1(mavlink_connection, system_status, logger, sensor_manager=None):
    """G√∂rev 1'i √ßalƒ±≈ütƒ±r (dƒ±≈ü aray√ºz fonksiyonu)"""
    mission = Mission1Controller(mavlink_connection, system_status, logger, sensor_manager)
    
    try:
        # G√∂revi ba≈ülat
        if not mission.initialize_mission():
            logger.error("G√∂rev 1 ba≈ülatma ba≈üarƒ±sƒ±z!")
            return False
            
        # Ana g√∂rev d√∂ng√ºs√º
        success = mission.start_mission()
        
        # Sonu√ß raporu
        status = mission.get_mission_status()
        mission_time = format_time(status['mission_time'])
        
        if success:
            logger.info(f"‚úÖ G√ñREV 1 BA≈ûARILI! S√ºre: {mission_time}, Mesafe: {status['total_distance']:.1f}m")
        else:
            logger.error(f"‚ùå G√ñREV 1 BA≈ûARISIZ! S√ºre: {mission_time}")
            
        return success
        
    except Exception as e:
        logger.error(f"G√∂rev 1 √ßalƒ±≈ütƒ±rma hatasƒ±: {e}")
        return False
        
    finally:
        mission.cleanup()
