#!/usr/bin/env python3
"""
TEKNOFEST Su Altƒ± ROV - Advanced Terminal GUI
Pixhawk PX4 PIX 2.4.8 Serial MAVLink Control System
Real-time IMU, Depth Sensor, GPIO Integration
"""

import os
import sys
import curses
import time
import json
import math
import threading
import signal
import traceback
from concurrent.futures import ThreadPoolExecutor, TimeoutError

# Import attempt for MAVLink - debug mode for import issues
try:
    from mavlink_handler import MAVLinkHandler
    MAVLINK_AVAILABLE = True
    print("‚úÖ MAVLink handler loaded successfully")
except ImportError as e:
    print(f"‚ùå MAVLink handler import error: {e}")
    MAVLINK_AVAILABLE = False

# GPIO Controller import
try:
    from gpio_controller import GPIOController
    GPIO_AVAILABLE = True
    print("‚úÖ GPIO controller loaded successfully")
except ImportError as e:
    print(f"‚ö†Ô∏è GPIO controller import error: {e}")
    print("üí° GPIO functions will be disabled in simulation mode")
    GPIO_AVAILABLE = False

# Depth sensor import
try:
    from depth_sensor import D300DepthSensor
    DEPTH_SENSOR_AVAILABLE = True
    print("‚úÖ Depth sensor loaded successfully")
except ImportError as e:
    print(f"‚ö†Ô∏è Depth sensor import error: {e}")
    print("üí° Depth sensor will use MAVLink data")
    DEPTH_SENSOR_AVAILABLE = False

# Navigation engine import
try:
    from navigation_engine import NavigationEngine
    NAVIGATION_AVAILABLE = True
    print("‚úÖ Navigation engine loaded successfully")
except ImportError as e:
    print(f"‚ö†Ô∏è Navigation engine import error: {e}")
    NAVIGATION_AVAILABLE = False

class GPIOIntegration:
    """GPIO ve harici sens√∂r entegrasyonu"""
    
    def __init__(self, config):
        """GPIO integration ba≈ülat"""
        self.config = config
        
        if GPIO_AVAILABLE:
            self.gpio = GPIOController(config)
            self.gpio_initialized = self.gpio.initialize()
        else:
            self.gpio = None
            self.gpio_initialized = False
        
        # Depth sensor
        if DEPTH_SENSOR_AVAILABLE:
            try:
                # √ñnce I2C dene, ba≈üarƒ±sƒ±z olursa simulation
                self.depth_sensor = D300DepthSensor(simulation_mode=False)
                if not self.depth_sensor.connect():
                    # I2C ba≈üarƒ±sƒ±z, simulation'a ge√ß
                    self.depth_sensor = D300DepthSensor(simulation_mode=True)
                    self.depth_sensor.connect()
                    print("üéÆ D300 depth sensor sim√ºlasyon modunda")
                self.depth_sensor_available = True
            except Exception as e:
                print(f"‚ö†Ô∏è Depth sensor ba≈ülatma hatasƒ±: {e}")
                self.depth_sensor = None
                self.depth_sensor_available = False
        else:
            self.depth_sensor = None
            self.depth_sensor_available = False
        
        # Emergency callback
        self.emergency_callback = None
        
        if self.gpio_initialized:
            print("‚úÖ GPIO integration ba≈üarƒ±yla ba≈ülatƒ±ldƒ±")
        else:
            print("‚ö†Ô∏è GPIO sim√ºlasyon modunda √ßalƒ±≈üƒ±yor")
    
    def set_emergency_callback(self, callback):
        """Acil durum callback ayarla"""
        self.emergency_callback = callback
    
    def emergency_button_pressed(self):
        """Acil durum butonu basƒ±ldƒ±ƒüƒ±nda √ßaƒürƒ±lan fonksiyon"""
        if self.emergency_callback:
            try:
                self.emergency_callback()
            except Exception as e:
                print(f"‚ùå Emergency callback error: {e}")
        
        # LED ve buzzer ile acil durum sinyali
        if self.gpio_initialized:
            self.gpio.emergency_led_pattern()
            self.gpio.buzzer_beep(2000, 1.0, 80)
    
    def set_system_status_led(self, status):
        """Sistem durumu LED'i"""
        if self.gpio_initialized:
            self.gpio.status_led_pattern(status)
    
    def set_connection_status_led(self, connected, armed=False):
        """Baƒülantƒ± durumu LED g√∂stergesi"""
        if not self.gpio_initialized:
            return
        
        if connected:
            if armed:
                self.gpio.set_rgb_led(0, 100, 0)  # Ye≈üil - Armed
            else:
                self.gpio.set_rgb_led(0, 0, 100)  # Mavi - Connected
        else:
            self.gpio.set_rgb_led(100, 0, 0)  # Kƒ±rmƒ±zƒ± - Disconnected
    
    def beep_success(self):
        """Ba≈üarƒ± sesi"""
        if self.gpio_initialized:
            self.gpio.buzzer_beep(1500, 0.2, 50)
    
    def beep_error(self):
        """Hata sesi"""
        if self.gpio_initialized:
            self.gpio.buzzer_beep(800, 0.5, 70)
    
    def beep_warning(self):
        """Uyarƒ± sesi"""
        if self.gpio_initialized:
            self.gpio.buzzer_beep(1200, 0.3, 60)
    
    def read_button(self):
        """Kontrol butonunu oku"""
        if self.gpio_initialized:
            return self.gpio.read_button()
        return False
    
    def get_depth_data(self):
        """Depth sensor verilerini al"""
        if self.depth_sensor_available and self.depth_sensor:
            return self.depth_sensor.get_sensor_data()
        return None
    
    def cleanup(self):
        """GPIO temizliƒüi"""
        if self.gpio_initialized:
            self.gpio.cleanup()
        if self.depth_sensor_available and self.depth_sensor:
            self.depth_sensor.disconnect()

class MissionPlanner:
    """Basit mission planning sistemi"""
    
    def __init__(self):
        """Mission planner ba≈ülat"""
        self.missions = []
        self.current_mission = None
        self.mission_thread = None
        self.mission_active = False
        
        # Mission t√ºrleri
        self.mission_types = {
            'F': ('ƒ∞leri Git', 'distance'),
            'B': ('Geri Git', 'distance'),
            'L': ('Sol Git', 'distance'),
            'R': ('Saƒü Git', 'distance'),
            'U': ('Yukarƒ±', 'distance'),
            'D': ('A≈üaƒüƒ±', 'distance'),
            'Y': ('Yaw D√∂n', 'angle'),
            'W': ('Bekle', 'time'),
            'S': ('Y√ºzeye √áƒ±k', 'none')
        }
    
    def add_mission(self, command, value):
        """Mission ekle"""
        if command in self.mission_types:
            mission_name, param_type = self.mission_types[command]
            self.missions.append({
                'command': command,
                'name': mission_name,
                'value': value,
                'param_type': param_type
            })
            return True
        return False
    
    def clear_missions(self):
        """T√ºm mission'larƒ± temizle"""
        self.missions = []
        self.mission_active = False
    
    def get_mission_summary(self):
        """Mission √∂zetini d√∂nd√ºr"""
        return [f"{m['name']}: {m['value']}" for m in self.missions]
    
    def start_mission(self):
        """Mission'larƒ± ba≈ülat"""
        if self.missions and not self.mission_active:
            self.mission_active = True
            return True
        return False

class TestScriptManager:
    """Test script y√∂netim sistemi"""
    
    def __init__(self):
        """Test script manager ba≈ülat"""
        self.scripts = {
            '1': 'Test/test_servo_control.py',
            '2': 'Test/test_motor_control.py',
            '3': 'Test/test_aux1_servo.py',
            '4': 'Test/test_aux3_servo.py',
            '5': 'Test/test_aux4_servo.py',
            '6': 'Test/test_aux5_servo.py',
            '7': 'Test/test_all_aux_servos.py',
            '8': 'scripts/motor_test.py',
            '9': 'scripts/emergency_stop.py'
        }
        
        self.running_script = None
        self.script_thread = None
    
    def get_script_list(self):
        """Script listesini d√∂nd√ºr"""
        return [(k, v) for k, v in self.scripts.items()]
    
    def run_script(self, script_id, callback=None):
        """Script'i √ßalƒ±≈ütƒ±r"""
        if script_id in self.scripts and not self.running_script:
            script_path = self.scripts[script_id]
            self.running_script = script_id
            
            def execute_script():
                try:
                    import subprocess
                    result = subprocess.run([sys.executable, script_path], 
                                          capture_output=True, text=True, timeout=30)
                    success = result.returncode == 0
                    if callback:
                        callback(script_id, success, result.stdout, result.stderr)
                except Exception as e:
                    if callback:
                        callback(script_id, False, "", str(e))
                finally:
                    self.running_script = None
            
            self.script_thread = threading.Thread(target=execute_script, daemon=True)
            self.script_thread.start()
            return True
        return False

class AdvancedTerminalGUI:
    """Terminal GUI ana sƒ±nƒ±fƒ±"""
    def __init__(self):
        """Terminal GUI ba≈ülat"""
        # Environment variable support for serial
        self.serial_port = os.getenv("MAV_ADDRESS", "/dev/ttyACM0")
        self.baud_rate = int(os.getenv("MAV_BAUD", "115200"))
        
        print(f"üîß Terminal GUI Serial Configuration:")
        print(f"   Port: {self.serial_port}")
        print(f"   Baud: {self.baud_rate}")
        
        # Config y√ºkleme
        self.config = self.load_config()
        
        # MAVLink handler
        if MAVLINK_AVAILABLE:
            self.mavlink = MAVLinkHandler()
            self.mavlink_available = True
        else:
            self.mavlink = None
            self.mavlink_available = False
        
        # GPIO integration
        self.gpio_integration = GPIOIntegration(self.config)
        
        # Navigation engine
        if NAVIGATION_AVAILABLE and self.mavlink:
            self.navigation = NavigationEngine(self.mavlink)
            self.navigation_available = True
        else:
            self.navigation = None
            self.navigation_available = False
        
        # Mission planner
        self.mission_planner = MissionPlanner()
        
        # Test script manager
        self.test_scripts = TestScriptManager()
        
        # GUI state
        self.current_menu = "main"  # main, gpio_test, mission_plan, test_scripts
        self.menu_selection = 0
        
        # Control values
        self.motor_power = 0.0
        self.servo_roll = 0.0
        self.servo_pitch = 0.0
        self.servo_yaw = 0.0
        
        # System data
        self.imu_data = None
        self.depth_data = None
        self.tcp_data = {}
        self.gpio_data = {}
        
        # Logging
        self.log_messages = []
        self.max_logs = 100
        
        # Threading
        self.tcp_thread = None
        self.tcp_running = False
        self.data_lock = threading.Lock()
        
        # GUI settings
        self.show_imu_details = True
        self.show_depth_details = True
        self.show_raw_data = False
        
        # Emergency callback setup
        self.gpio_integration.set_emergency_callback(self.emergency_stop_callback)
        
        print("‚úÖ Terminal GUI initialization complete")
    
    def load_config(self):
        """Config dosyasƒ±nƒ± y√ºkle"""
        config_path = "config/hardware_config.json"
        
        # Default config with serial connection
        default_config = {
            "pixhawk": {
                "servo_channels": {
                    "fin_front_left": 1,
                    "fin_front_right": 3,
                    "fin_rear_left": 4,
                    "fin_rear_right": 5,
                    "main_motor": 6
                },
                "pwm_limits": {"min": 1000, "neutral": 1500, "max": 2000}
            },
            "raspberry_pi": {
                "gpio": {
                    "buzzer": 7, "control_button": 13,
                    "led_red": 4, "led_green": 5, "led_blue": 6,
                    "warning_led": 8, "system_status_led": 10
                },
                "i2c": {"bus_number": 1, "depth_sensor_address": "0x76"}
            },
            "mavlink": {"connection_string": self.serial_port, "baudrate": self.baud_rate},
            "network": {"web_gui_port": 5000, "log_level": "INFO"}
        }
        
        try:
            with open(config_path, 'r') as f:
                config = json.load(f)
            
            # Environment variables'dan serial ayarlarƒ±nƒ± g√ºncelle
            if "mavlink" in config:
                config["mavlink"]["connection_string"] = self.serial_port
                config["mavlink"]["baudrate"] = self.baud_rate
            
            print("‚úÖ Config ba≈üarƒ±yla y√ºklendi")
            return config
            
        except FileNotFoundError:
            print("‚ö†Ô∏è Config dosyasƒ± bulunamadƒ±, varsayƒ±lan config kullanƒ±lƒ±yor")
            return default_config
        except json.JSONDecodeError as e:
            print(f"‚ùå Config dosyasƒ± parse hatasƒ±: {e}")
            return default_config
        except Exception as e:
            print(f"‚ùå Config y√ºkleme hatasƒ±: {e}")
            return default_config
    
    def log(self, message):
        """Thread-safe log"""
        timestamp = time.strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}"
        
        with self.data_lock:
            self.log_messages.append(log_entry)
            # Max log limit kontrol√º
            if len(self.log_messages) > self.max_logs:
                self.log_messages = self.log_messages[-self.max_logs:]
    
    def emergency_stop_callback(self):
        """Acil durum butonu callback"""
        self.log("üö® ACƒ∞L DURUM BUTONU BASILDI - T√úM Sƒ∞STEMLER DURDURULUYOR!")
        
        # T√ºm kontrolleri sƒ±fƒ±rla
        self.servo_roll = 0.0
        self.servo_pitch = 0.0
        self.servo_yaw = 0.0
        self.motor_power = 0.0
        
        # MAVLink emergency stop
        if self.mavlink_available and self.mavlink and self.mavlink.connected:
            try:
                self.mavlink.emergency_stop()
                self.log("‚úÖ MAVLink emergency stop g√∂nderildi!")
            except Exception as e:
                self.log(f"‚ùå Emergency stop hatasƒ±: {e}")
        
        # G√∂revleri durdur
        self.mission_planner.mission_active = False
        
        # Buzzer pattern √ßal
        self.gpio_integration.beep_error()
        
        self.log("‚úÖ Acil durum prosed√ºr√º tamamlandƒ±!")
    
    def init_systems(self):
        """Sistem bile≈üenlerini ba≈ülat - Serial MAVLink"""
        self.log("üöÄ TEKNOFEST ROV Terminal GUI ba≈ülatƒ±lƒ±yor...")
        self.log(f"üì° Serial baƒülantƒ±: {self.serial_port} @ {self.baud_rate} baud")
        
        # GPIO sistem durumunu belirt
        if self.gpio_integration.gpio_initialized:
            self.log("‚úÖ GPIO sistemleri hazƒ±r - Buzzer/LED/Button aktif!")
            self.gpio_integration.set_system_status_led('connecting')
        else:
            self.log("‚ö†Ô∏è GPIO sistemler devre dƒ±≈üƒ± - sadece Serial kontrol")
        
        # D300 derinlik sens√∂r√º durumu
        if self.gpio_integration.depth_sensor_available:
            self.log("‚úÖ D300 derinlik sens√∂r√º hazƒ±r - I2C/MAVLink data aktif!")
        else:
            self.log("‚ö†Ô∏è D300 derinlik sens√∂r√º - sadece MAVLink data")
        
        # Serial MAVLink baƒülantƒ±sƒ±
        if self.mavlink_available:
            try:
                self.log(f"üì° Serial MAVLink baƒülantƒ±sƒ± ba≈ülatƒ±lƒ±yor...")
                self.log(f"üîß Port: {self.serial_port}, Baud: {self.baud_rate}")
                
                connect_result = self.mavlink.connect()
                self.log(f"üîç Serial baƒülantƒ± sonucu: {connect_result}")
                
                if connect_result:
                    self.log("‚úÖ Serial MAVLink baƒülantƒ±sƒ± kuruldu!")
                    self.log(f"üìä Pixhawk System ID: {self.mavlink.master.target_system}")
                    
                    # System check
                    if self.mavlink.check_system_status():
                        arm_status = "ARMED" if self.mavlink.armed else "DISARMED"
                        self.log(f"üéØ Pixhawk durumu: {arm_status}")
                    
                    # Data stream ba≈ülat
                    self.start_serial_data_thread()
                    
                    # GPIO status update
                    if self.gpio_integration.gpio_initialized:
                        self.gpio_integration.set_connection_status_led(True, self.mavlink.armed)
                    
                else:
                    self.log("‚ùå Serial MAVLink baƒülantƒ±sƒ± ba≈üarƒ±sƒ±z!")
                    self.log(f"üí° Kontrol: {self.serial_port} portu, {self.baud_rate} baud rate")
                    self.log("üí° Pixhawk baƒülƒ± ve ArduSub √ßalƒ±≈üƒ±yor mu?")
                    
            except Exception as e:
                self.log(f"‚ùå Serial baƒülantƒ± hatasƒ±: {e}")
                self.log("üí° Pixhawk serial baƒülantƒ±sƒ±nƒ± kontrol edin")
        else:
            self.log("‚ùå MAVLink handler y√ºklenemedi - sadece GPIO aktif")
        
        # Final system check
        self.log("üîç Sistem kontrol√º...")
        if self.mavlink_available and self.mavlink and self.mavlink.connected:
            self.log("üéØ HAZIR: Serial baƒülƒ±, Pixhawk aktif, kontroller hazƒ±r!")
            if self.gpio_integration.gpio_initialized:
                self.log("üéØ GPIO: Buzzer/LED/Button aktif, acil durum butonu hazƒ±r!")
            if self.gpio_integration.depth_sensor_available:
                self.log("üéØ D300: I2C derinlik sens√∂r√º aktif!")
        else:
            self.log("‚ö†Ô∏è Dƒ∞KKAT: Serial baƒülantƒ± yok - sadece GPIO/I2C test modu")
            
        self.log("‚úÖ Sistem ba≈ülatma tamamlandƒ±!")
    
    def start_serial_data_thread(self):
        """Serial veri thread'ini ba≈ülat"""
        self.tcp_running = True  # Variable adƒ±nƒ± koruyorum uyumluluk i√ßin
        self.tcp_thread = threading.Thread(target=self.serial_data_loop, daemon=True)
        self.tcp_thread.start()
        self.log("üîÑ Serial veri thread'i ba≈ülatƒ±ldƒ± (10Hz)")
    
    def serial_data_loop(self):
        """Serial veri d√∂ng√ºs√º - IMU, GPS, Depth data"""
        self.log("üì° Serial data loop ba≈ülatƒ±ldƒ±...")
        last_log_time = 0
        data_counter = 0
        
        while self.tcp_running and hasattr(self, 'running') and self.running:
            try:
                current_time = time.time()
                
                # MAVLink'den veri al
                if self.mavlink_available and self.mavlink and self.mavlink.connected:
                    # IMU data
                    imu_data = self.mavlink.get_imu_data()
                    if imu_data:
                        with self.data_lock:
                            self.imu_data = imu_data
                            self.tcp_data['connected'] = True
                            self.tcp_data['last_update'] = current_time
                        data_counter += 1
                    
                    # Depth data (MAVLink'den)
                    depth_data = self.mavlink.get_depth_data()
                    if depth_data:
                        with self.data_lock:
                            self.depth_data = depth_data
                            self.depth_data['connected'] = True
                    
                    # GPS data
                    gps_data = self.mavlink.get_gps_data()
                    if gps_data:
                        with self.data_lock:
                            self.tcp_data['gps'] = gps_data
                
                # GPIO/I2C verilerini g√ºncelle
                self.update_gpio_data()
                
                # Calculate live orientation
                if self.imu_data:
                    self.calculate_live_orientation(self.imu_data)
                
                # Periodic logging (5 saniyede bir)
                if current_time - last_log_time > 5.0:
                    rate = data_counter / 5.0 if data_counter > 0 else 0
                    self.log(f"üìä Serial data rate: {rate:.1f} Hz, IMU packets: {data_counter}")
                    last_log_time = current_time
                    data_counter = 0
                
                time.sleep(0.1)  # 10Hz
                
            except Exception as e:
                self.log(f"‚ùå Serial data loop error: {e}")
                time.sleep(0.5)
        
        self.log("üì° Serial data loop durduruldu")
    
    def update_gpio_data(self):
        """GPIO ve I2C veri g√ºncelleme"""
        # D300 derinlik sens√∂r√º verisi g√ºncelle (I2C'den direkt)
        if self.gpio_integration.depth_sensor_available:
            depth_data = self.gpio_integration.get_depth_data()
            if depth_data:
                with self.data_lock:
                    # I2C depth data'yƒ± MAVLink ile birle≈ütir
                    if not self.depth_data or not self.depth_data.get('connected', False):
                        self.depth_data = depth_data
                        self.depth_data['source'] = 'I2C'
        
        # GPIO buton durumu kontrol
        if self.gpio_integration.gpio_initialized:
            button_pressed = self.gpio_integration.read_button()
            if button_pressed:
                self.gpio_integration.emergency_button_pressed()
    
    def update_tcp_data(self):
        """TCP data update (backward compatibility i√ßin isim korundu)"""
        # Bu fonksiyon artƒ±k serial data'yƒ± i≈üliyor
        return self.serial_data_loop()
    
    def calculate_live_orientation(self, raw_imu):
        """Live roll/pitch/yaw hesapla"""
        try:
            # Raw IMU verilerini al (SI units)
            accel_x, accel_y, accel_z = raw_imu[0], raw_imu[1], raw_imu[2]
            gyro_x, gyro_y, gyro_z = raw_imu[3], raw_imu[4], raw_imu[5]
            
            # Accelerometer'dan roll/pitch hesapla
            if abs(accel_z) > 0.001:
                roll_rad = math.atan2(accel_y, accel_z)
                pitch_rad = math.atan2(-accel_x, math.sqrt(accel_y*accel_y + accel_z*accel_z))
                
                # Radyan'dan dereceye
                roll_deg = math.degrees(roll_rad)
                pitch_deg = math.degrees(pitch_rad)
            else:
                roll_deg = getattr(self, 'last_roll', 0.0)
                pitch_deg = getattr(self, 'last_pitch', 0.0)
            
            # YAW integration
            dt = 0.1  # 10Hz
            gyro_z_deg = math.degrees(gyro_z)  # rad/s to deg/s
            
            # ƒ∞lk kez √ßalƒ±≈üƒ±yorsa YAW'ƒ± 0'dan ba≈ülat
            if not hasattr(self, 'current_yaw'):
                self.current_yaw = 0.0
            
            # YAW g√ºncelle
            yaw_change = gyro_z_deg * dt
            self.current_yaw += yaw_change
            
            # Yaw normalize (-180 to +180)
            while self.current_yaw > 180:
                self.current_yaw -= 360
            while self.current_yaw < -180:
                self.current_yaw += 360
            
            # Store values
            self.last_roll = roll_deg
            self.last_pitch = pitch_deg
            
            # Update live IMU structure for display compatibility
            if not hasattr(self, 'live_imu'):
                self.live_imu = {}
            
            self.live_imu.update({
                'roll': roll_deg,
                'pitch': pitch_deg,
                'yaw': self.current_yaw,
                'connected': True,
                'last_update': time.time(),
                'update_rate': 10
            })
            
        except Exception as e:
            self.log(f"‚ùå Orientation hesaplama hatasƒ±: {e}")
    
    def init_curses(self, stdscr):
        """Curses aray√ºz√ºn√º ba≈ülat"""
        self.stdscr = stdscr
        curses.curs_set(0)  # Cursor gizle
        curses.noecho()
        curses.cbreak()
        stdscr.keypad(True)
        stdscr.nodelay(True)
        stdscr.timeout(50)  # 20Hz UI update
        
        # Renkler
        curses.start_color()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)   # Ba≈üarƒ±lƒ±
        curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)     # Hata
        curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)  # Uyarƒ±
        curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)    # Info
        curses.init_pair(5, curses.COLOR_MAGENTA, curses.COLOR_BLACK) # √ñzel
        curses.init_pair(6, curses.COLOR_WHITE, curses.COLOR_BLACK)   # Normal
        
        # Ekran boyutu
        self.height, self.width = stdscr.getmaxyx()
        self.log(f"üñ•Ô∏è Terminal boyutu: {self.width}x{self.height}")
    
    def draw_header(self):
        """Ba≈ülƒ±k √ßiz"""
        title = f"üöÄ TEKNOFEST ROV - Serial MAVLink Terminal [{self.serial_port}@{self.baud_rate}] üöÄ"
        self.stdscr.addstr(0, max(0, (self.width - len(title)) // 2), title, curses.color_pair(4) | curses.A_BOLD)
        
        # Durum satƒ±rƒ± - GPIO/I2C durumu eklendi
        status_line = 1
        serial_status = "‚úÖ Serial BAƒûLI" if self.tcp_data.get('connected', False) else "‚ùå Serial BAƒûLI DEƒûƒ∞L"
        armed_status = "üî¥ ARMED" if (self.mavlink and self.mavlink.armed) else "üü¢ DISARMED"
        gpio_status = "üîß GPIO/I2C" if (self.gpio_integration.gpio_initialized or self.gpio_integration.depth_sensor_available) else "‚ùå NO GPIO"
        menu_status = f"üìã {self.current_menu.upper()}"
        
        self.stdscr.addstr(status_line, 2, f"Serial: {serial_status}", curses.color_pair(1 if self.tcp_data.get('connected', False) else 2))
        self.stdscr.addstr(status_line, 25, f"Durum: {armed_status}", curses.color_pair(2 if (self.mavlink and self.mavlink.armed) else 1))
        self.stdscr.addstr(status_line, 45, f"HW: {gpio_status}", curses.color_pair(1 if (self.gpio_integration.gpio_initialized or self.gpio_integration.depth_sensor_available) else 2))
        self.stdscr.addstr(status_line, 65, f"Kontrol: RAW", curses.color_pair(5))
        self.stdscr.addstr(status_line, 85, f"Men√º: {menu_status}", curses.color_pair(4))
        
        # Ayƒ±rƒ±cƒ± √ßizgi
        self.stdscr.addstr(2, 0, "=" * self.width, curses.color_pair(6))
    
    def draw_live_imu_display(self):
        """Live IMU display - simplified"""
        start_row = 3
        self.stdscr.addstr(start_row, 4, "üìä LIVE IMU/ORIENTATION", curses.color_pair(4) | curses.A_BOLD)
        
        # Initialize live_imu if not exists
        if not hasattr(self, 'live_imu'):
            self.live_imu = {'connected': False, 'roll': 0, 'pitch': 0, 'yaw': 0, 'last_update': 0, 'update_rate': 0}
        
        # IMU verisi varsa g√∂ster
        if self.live_imu.get('connected', False):
            # Baƒülantƒ± durumu
            conn_status = "‚úÖ Serial LIVE"
            conn_color = curses.color_pair(1)
            data_age = time.time() - self.live_imu.get('last_update', 0)
            
            if data_age > 2.0:
                conn_status = "‚ö†Ô∏è DATA OLD"
                conn_color = curses.color_pair(3)
            
            self.stdscr.addstr(start_row + 1, 4, f"Durum: {conn_status} ({self.live_imu.get('update_rate', 0)}Hz)", conn_color)
            
            # Orientation deƒüerleri - angle bar ile
            roll_val = self.live_imu.get('roll', 0)
            pitch_val = self.live_imu.get('pitch', 0)
            yaw_val = self.live_imu.get('yaw', 0)
            
            self.stdscr.addstr(start_row + 2, 4, f"ROLL:  {roll_val:+6.1f} ¬∞", curses.color_pair(1 if abs(roll_val) < 10 else 3))
            self.stdscr.addstr(start_row + 3, 4, f"PITCH: {pitch_val:+6.1f} ¬∞", curses.color_pair(1 if abs(pitch_val) < 10 else 3))
            self.stdscr.addstr(start_row + 4, 4, f"YAW:   {yaw_val:+6.1f} ¬∞", curses.color_pair(1))
            
            # Angle bars
            self.draw_angle_bar(start_row + 2, 25, roll_val, "ROLL")
            self.draw_angle_bar(start_row + 3, 25, pitch_val, "PITCH")
            self.draw_angle_bar(start_row + 4, 25, yaw_val, "YAW")
            
        else:
            # Baƒülantƒ± yok
            self.stdscr.addstr(start_row + 1, 4, "Durum: ‚ùå BAƒûLANTI YOK", curses.color_pair(2))
            self.stdscr.addstr(start_row + 2, 4, "ROLL:  ---- ¬∞", curses.color_pair(2))
            self.stdscr.addstr(start_row + 3, 4, "PITCH: ---- ¬∞", curses.color_pair(2))
            self.stdscr.addstr(start_row + 4, 4, "YAW:   ---- ¬∞", curses.color_pair(2))
            self.stdscr.addstr(start_row + 6, 4, "‚ùå Serial baƒülantƒ±sƒ± yok - IMU verisi alƒ±namƒ±yor", curses.color_pair(2))
    
    def draw_depth_sensor_display(self):
        """D300 Derinlik sens√∂r√º g√∂r√ºnt√ºleme - YENƒ∞!"""
        start_row = 9
        
        with self.data_lock:
            # Ba≈ülƒ±k
            self.stdscr.addstr(start_row, 55, "üåä D300 DEPTH SENSOR (I2C)", curses.color_pair(4) | curses.A_BOLD)
            
            if self.gpio_integration.depth_sensor_available and self.depth_data['connected']:
                # Derinlik verisi
                depth_val = self.depth_data['depth_m']
                depth_color = curses.color_pair(1) if depth_val < 5 else curses.color_pair(3) if depth_val < 8 else curses.color_pair(2)
                self.stdscr.addstr(start_row + 1, 57, f"DEPTH:   {depth_val:7.2f}m", depth_color | curses.A_BOLD)
                
                # Sƒ±caklƒ±k verisi
                temp_val = self.depth_data['temperature_c']
                temp_color = curses.color_pair(1) if 15 < temp_val < 30 else curses.color_pair(3)
                self.stdscr.addstr(start_row + 2, 57, f"TEMP:    {temp_val:7.1f}¬∞C", temp_color)
                
                # Basƒ±n√ß verisi
                pressure_val = self.depth_data['pressure_mbar']
                self.stdscr.addstr(start_row + 3, 57, f"PRESS:   {pressure_val:7.1f}mb", curses.color_pair(6))
                
                # I2C durum
                self.stdscr.addstr(start_row + 4, 57, "I2C: ‚úÖ ACTIVE", curses.color_pair(1))
                
            else:
                self.stdscr.addstr(start_row + 1, 57, "DEPTH:   ----  m", curses.color_pair(2))
                self.stdscr.addstr(start_row + 2, 57, "TEMP:    ----  ¬∞C", curses.color_pair(2))
                self.stdscr.addstr(start_row + 3, 57, "PRESS:   ----  mb", curses.color_pair(2))
                if self.gpio_integration.depth_sensor_available:
                    self.stdscr.addstr(start_row + 4, 57, "I2C: ‚ö†Ô∏è NO DATA", curses.color_pair(3))
                else:
                    self.stdscr.addstr(start_row + 4, 57, "I2C: ‚ùå DISABLED", curses.color_pair(2))
    
    def draw_angle_bar(self, row, col, angle, label):
        """A√ßƒ± i√ßin g√∂rsel √ßubuk √ßiz"""
        try:
            # -90 ile +90 derece arasƒ± normalize et
            normalized = max(-90, min(90, angle))
            bar_length = 20
            center = bar_length // 2
            
            # √áubuk karakteri hesapla
            pos = int((normalized / 90.0) * center) + center
            pos = max(0, min(bar_length - 1, pos))
            
            # √áubuk √ßiz
            bar = ['‚îÄ'] * bar_length
            bar[center] = '‚îÇ'  # Merkez
            bar[pos] = '‚ñà'     # Mevcut pozisyon
            
            bar_str = ''.join(bar)
            self.stdscr.addstr(row, col, f"{bar_str} {normalized:+5.1f}¬∞", curses.color_pair(6))
            
        except:
            pass
    
    def draw_controls_and_menu(self):
        """Kontrol ve men√º bilgileri"""
        start_row = 14  # Depth sensor i√ßin yer a√ßƒ±ldƒ±
        
        if self.current_menu == "main":
            self.draw_main_controls(start_row)
        elif self.current_menu == "mission_plan":
            self.draw_mission_planning(start_row)
        elif self.current_menu == "test_scripts":
            self.draw_test_script_menu(start_row)
        elif self.current_menu == "gpio_test":
            self.draw_gpio_test_menu(start_row)
    
    def draw_main_controls(self, start_row):
        """Ana kontrol men√ºs√º - MOTOR KONTROL EKLENDƒ∞"""
        self.stdscr.addstr(start_row, 2, "‚å®Ô∏è  MANUEL KONTROL:", curses.color_pair(4) | curses.A_BOLD)
        
        # Real-time kontrol durumu
        self.stdscr.addstr(start_row + 1, 4, f"Roll:  {self.servo_values['roll']:+4.0f}¬∞ [A/D]", curses.color_pair(5))
        self.stdscr.addstr(start_row + 2, 4, f"Pitch: {self.servo_values['pitch']:+4.0f}¬∞ [W/S]", curses.color_pair(5))
        # YAW deƒüeri daha belirgin g√∂r√ºnt√ºleme
        yaw_display_color = curses.color_pair(3) | curses.A_BOLD if abs(self.servo_values['yaw']) > 0 else curses.color_pair(5)
        self.stdscr.addstr(start_row + 3, 4, f"Yaw:   {self.servo_values['yaw']:+4.0f}¬∞ [Q/E]", yaw_display_color)
        
        # MOTOR KONTROL - YENƒ∞ VE DETAYLI!
        motor_display_color = curses.color_pair(1) if abs(self.motor_value) < 30 else curses.color_pair(3) if abs(self.motor_value) < 70 else curses.color_pair(2)
        self.stdscr.addstr(start_row + 4, 4, f"Motor: {self.motor_value:+4.0f}% [J/K] [I/M boost]", motor_display_color | curses.A_BOLD)
        
        # GPIO durumu g√∂ster
        if self.gpio_integration.gpio_initialized:
            self.stdscr.addstr(start_row + 5, 4, "GPIO:  ‚úÖ Buzzer/LED/Button aktif", curses.color_pair(1))
        else:
            self.stdscr.addstr(start_row + 5, 4, "GPIO:  ‚ùå Devre dƒ±≈üƒ±", curses.color_pair(2))
        
        # Hƒ±zlƒ± y√ºzd√ºrme modu durumu g√∂ster
        if hasattr(self, 'quick_swim_mode') and self.quick_swim_mode:
            self.stdscr.addstr(start_row + 6, 4, "üèä HIZLI Y√úZDƒ∞RME MODU AKTƒ∞F!", curses.color_pair(2) | curses.A_BOLD)
            self.stdscr.addstr(start_row + 7, 6, "1-3: Y√ºz/Sƒ±ƒü/Derin  4-5: Sol/Saƒü  6-7: ƒ∞leri/Geri  ESC: √áƒ±kƒ±≈ü", curses.color_pair(3))
        
        # Komut men√ºs√º - MOTOR KONTROL VE HIZLI Y√úZDƒ∞RME EKLENDƒ∞
        menu_start_row = start_row + 8 if hasattr(self, 'quick_swim_mode') and self.quick_swim_mode else start_row + 7
        self.stdscr.addstr(menu_start_row, 2, "üìã KONTROL KOMUTLARI:", curses.color_pair(4) | curses.A_BOLD)
        
        commands = [
            "W/S: Pitch ¬±",       "A/D: Roll ¬±",        "Q/E: Yaw ¬±",
            "J/K: Motor ¬±5%",     "I/M: Motor ¬±15%",    "N: Motor STOP",
            "R/F: RAW/PID Mode",  "X: Hƒ±zlƒ± Y√ºzme",     "0: Mission Plan",
            "T: Test Scripts",    "G: GPIO Test",       "Z: Serial Debug",
            "B: Buzzer Test",     "Space: ARM/DISARM",  "C: Config",
        ]
        
        row = menu_start_row + 1
        col = 4
        for i, cmd in enumerate(commands):
            if i % 3 == 0 and i > 0:
                row += 1
                col = 4
            if cmd:
                self.stdscr.addstr(row, col, cmd[:18], curses.color_pair(6))
            col += 22
    
    def draw_gpio_test_menu(self, start_row):
        """GPIO test men√ºs√º - YENƒ∞!"""
        self.stdscr.addstr(start_row, 2, "üîß GPIO/I2C TEST MEN√úS√ú:", curses.color_pair(4) | curses.A_BOLD)
        
        # GPIO durum bilgisi
        gpio_status = "‚úÖ AKTIF" if self.gpio_integration.gpio_initialized else "‚ùå DEVRE DI≈ûI"
        i2c_status = "‚úÖ AKTIF" if self.gpio_integration.depth_sensor_available else "‚ùå DEVRE DI≈ûI"
        
        self.stdscr.addstr(start_row + 1, 4, f"GPIO Durum: {gpio_status}", curses.color_pair(1 if self.gpio_integration.gpio_initialized else 2))
        self.stdscr.addstr(start_row + 2, 4, f"I2C D300:   {i2c_status}", curses.color_pair(1 if self.gpio_integration.depth_sensor_available else 2))
        
        # GPIO test komutlarƒ±
        self.stdscr.addstr(start_row + 4, 4, "GPIO TEST KOMUTLARI:", curses.color_pair(3))
        
        gpio_commands = [
            "1: Kƒ±rmƒ±zƒ± LED",     "2: Ye≈üil LED",       "3: Mavi LED",
            "4: Warning LED",     "5: Status LED",      "6: RGB LED Test",
            "7: Buzzer Beep",     "8: Buzzer Alarm",    "9: Button Test",
        ]
        
        row = start_row + 5
        for i, cmd in enumerate(gpio_commands):
            if i % 3 == 0 and i > 0:
                row += 1
            col = 4 + (i % 3) * 20
            if row < self.height - 5:
                self.stdscr.addstr(row, col, cmd, curses.color_pair(6))
        
        # I2C test komutlarƒ±
        self.stdscr.addstr(start_row + 9, 4, "I2C TEST KOMUTLARI:", curses.color_pair(3))
        self.stdscr.addstr(start_row + 10, 6, "D: D300 Depth Test", curses.color_pair(6))
        self.stdscr.addstr(start_row + 11, 6, "S: I2C Scanner", curses.color_pair(6))
        self.stdscr.addstr(start_row + 12, 6, "C: Calibrate Surface", curses.color_pair(6))
        
        # Men√º kontrol√º
        self.stdscr.addstr(start_row + 14, 4, "B: Ana men√ºye d√∂n", curses.color_pair(4))
    
    def draw_mission_planning(self, start_row):
        """G√∂rev planlama men√ºs√º"""
        self.stdscr.addstr(start_row, 2, "üéØ G√ñREV PLANLAMA Sƒ∞STEMƒ∞:", curses.color_pair(4) | curses.A_BOLD)
        
        # G√∂rev komutlarƒ±
        self.stdscr.addstr(start_row + 1, 4, "G√ñREV KOMUTLARI:", curses.color_pair(3))
        
        mission_cmds = [
            "1: SAƒûA (metre)", "2: SOLA (metre)", "3: ƒ∞LERƒ∞ (metre)",
            "4: GERƒ∞ (metre)", "5: YUKARI (metre)", "6: A≈ûAƒûI (metre)", 
            "7: SAƒû D√ñN (¬∞)", "8: SOL D√ñN (¬∞)", "9: DUR (saniye)",
        ]
        
        row = start_row + 2
        for i, cmd in enumerate(mission_cmds):
            if i % 3 == 0 and i > 0:
                row += 1
            col = 4 + (i % 3) * 25
            if row < self.height - 8:
                self.stdscr.addstr(row, col, cmd, curses.color_pair(6))
        
        # G√∂rev akƒ±≈üƒ± kontrolleri
        self.stdscr.addstr(start_row + 6, 4, "AKI≈û KONTROL:", curses.color_pair(3))
        self.stdscr.addstr(start_row + 7, 6, "ENTER: G√∂rev Akƒ±≈üƒ±nƒ± Ba≈ülat", curses.color_pair(1))
        self.stdscr.addstr(start_row + 8, 6, "C: G√∂revleri Temizle", curses.color_pair(2))
        self.stdscr.addstr(start_row + 9, 6, "B: Ana Men√ºye D√∂n", curses.color_pair(4))
        
        # Mevcut g√∂rev listesi
        mission_summary = self.mission_planner.get_mission_summary()
        if mission_summary:
            self.stdscr.addstr(start_row + 11, 4, "PLANLANAN G√ñREVLER:", curses.color_pair(3))
            for i, mission in enumerate(mission_summary[:6]):  # Max 6 g√∂rev g√∂ster
                if start_row + 12 + i < self.height - 2:
                    self.stdscr.addstr(start_row + 12 + i, 6, mission, curses.color_pair(5))
        else:
            self.stdscr.addstr(start_row + 11, 4, "Hen√ºz g√∂rev eklenmemi≈ü. Yukarƒ±daki komutlarƒ± kullanƒ±n.", curses.color_pair(6))
    
    def draw_test_script_menu(self, start_row):
        """Test script men√ºs√º"""
        self.stdscr.addstr(start_row, 2, "üîß TEST SCRIPT Y√ñNETƒ∞Cƒ∞Sƒ∞:", curses.color_pair(4) | curses.A_BOLD)
        
        # Test scriptleri listesi
        script_list = self.test_scripts.get_script_list()
        
        self.stdscr.addstr(start_row + 1, 4, "MEVCUT TEST SCRƒ∞PTLERƒ∞:", curses.color_pair(3))
        
        for i, (script_id, name) in enumerate(script_list):
            row = start_row + 2 + i
            if row < self.height - 5:  # Ekran sƒ±nƒ±rƒ± kontrol√º
                status_text = "√áALI≈ûIYOR..." if self.test_scripts.running_script == script_id else ""
                self.stdscr.addstr(row, 6, f"{script_id}: {name}", curses.color_pair(1 if not status_text else 3))
                self.stdscr.addstr(row, 35, f"- {script_list[script_id]}", curses.color_pair(6))
                if status_text:
                    self.stdscr.addstr(row, 70, status_text, curses.color_pair(3) | curses.A_BOLD)
        
        # Kontrol komutlarƒ±
        self.stdscr.addstr(start_row + 12, 4, "KONTROL:", curses.color_pair(3))
        self.stdscr.addstr(start_row + 13, 6, "1-9: ƒ∞lgili scripti √ßalƒ±≈ütƒ±r", curses.color_pair(6))
        self.stdscr.addstr(start_row + 14, 6, "S: √áalƒ±≈üan scripti durdur", curses.color_pair(2))
        self.stdscr.addstr(start_row + 15, 6, "B: Ana men√ºye d√∂n", curses.color_pair(4))
    
    def draw_logs(self):
        """Log mesajlarƒ± - optimize"""
        if self.height < 20:
            return
        
        log_start = self.height - 6
        max_logs = 4
        
        self.stdscr.addstr(log_start - 1, 2, "üìù SYSTEM LOGS:", curses.color_pair(4) | curses.A_BOLD)
        
        with self.data_lock:
            recent_logs = list(self.log_messages)[-max_logs:]
        
        for i, message in enumerate(recent_logs):
            if log_start + i < self.height - 1:
                # Log rengini belirle
                color = curses.color_pair(6)
                if "‚ùå" in message:
                    color = curses.color_pair(2)
                elif "‚ö†Ô∏è" in message:
                    color = curses.color_pair(3)
                elif "‚úÖ" in message:
                    color = curses.color_pair(1)
                
                # Mesajƒ± ekrana sƒ±ƒüacak ≈üekilde kƒ±salt
                display_message = message[:self.width - 4]
                try:
                    self.stdscr.addstr(log_start + i, 4, display_message, color)
                except:
                    pass

    def handle_keyboard(self):
        """Klavye giri≈üi - optimize edilmi≈ü"""
        key = self.stdscr.getch()
        
        if key == -1 or key == curses.ERR:
            return
        
        # Menu-specific handling
        if self.current_menu == "main":
            self.handle_main_controls(key)
        elif self.current_menu == "mission_plan":
            self.handle_mission_planning(key)
        elif self.current_menu == "test_scripts":
            self.handle_test_scripts(key)
        elif self.current_menu == "gpio_test":
            self.handle_gpio_test(key)
    
    def handle_main_controls(self, key):
        """Ana kontrol tu≈ülarƒ± - MOTOR KONTROL EKLENDƒ∞"""
        # Real-time servo kontrol - DEBUG EKLENDI
        if key == ord('w'):
            self.active_keys.add('w')
            self.log("üéÆ W tu≈üu basƒ±ldƒ± (Pitch+)")
        elif key == ord('s'):
            self.active_keys.add('s')
            self.log("üéÆ S tu≈üu basƒ±ldƒ± (Pitch-)")
        elif key == ord('a'):
            self.active_keys.add('a')
            self.log("üéÆ A tu≈üu basƒ±ldƒ± (Roll+)")
        elif key == ord('d'):
            self.active_keys.add('d')
            self.log("üéÆ D tu≈üu basƒ±ldƒ± (Roll-)")
        elif key == ord('q') or key == ord('Q'):
            self.active_keys.add('q')
            self.log("üéØ Q tu≈üu basƒ±ldƒ± - YAW SAƒû hareket ba≈ülatƒ±lƒ±yor!")
        elif key == ord('e') or key == ord('E'):
            self.active_keys.add('e')
            self.log("üéØ E tu≈üu basƒ±ldƒ± - YAW SOL hareket ba≈ülatƒ±lƒ±yor!")
        
        # MOTOR KONTROL TU≈ûLARI - TAM YENƒ∞ SISTEM!
        elif key == ord('j') or key == ord('J'):
            old_motor = self.motor_value
            self.motor_value = min(100, self.motor_value + 5)
            self.send_motor_command()
            self.log(f"üöÅ Motor ƒ∞LERƒ∞: {old_motor}% ‚Üí {self.motor_value}% (J tu≈üu)")
            self.gpio_integration.beep_success()
        elif key == ord('k') or key == ord('K'):
            old_motor = self.motor_value
            self.motor_value = max(-100, self.motor_value - 5)
            self.send_motor_command()
            self.log(f"üöÅ Motor GERƒ∞: {old_motor}% ‚Üí {self.motor_value}% (K tu≈üu)")
            self.gpio_integration.beep_success()
        elif key == ord('i') or key == ord('I'):
            old_motor = self.motor_value
            self.motor_value = min(100, self.motor_value + 15)
            self.send_motor_command()
            self.log(f"üöÅ Motor BOOST ƒ∞LERƒ∞: {old_motor}% ‚Üí {self.motor_value}% (I tu≈üu)")
            self.gpio_integration.beep_warning()
        elif key == ord('m') or key == ord('M'):
            old_motor = self.motor_value
            self.motor_value = max(-100, self.motor_value - 15)
            self.send_motor_command()
            self.log(f"üöÅ Motor BOOST GERƒ∞: {old_motor}% ‚Üí {self.motor_value}% (M tu≈üu)")
            self.gpio_integration.beep_warning()
        
        # Motor STOP - SPACE haricinde
        elif key == ord('n') or key == ord('N'):
            old_motor = self.motor_value
            self.motor_value = 0
            self.send_motor_command()
            self.log(f"üöÅ Motor STOP: {old_motor}% ‚Üí 0% (N tu≈üu)")
            self.gpio_integration.beep_error()
        
        # ARM/DISARM
        elif key == ord(' '):  # Space
            self.toggle_arm()
        
        # Kontrol modu
        elif key == ord('r'):
            self.control_mode = "RAW"
            self.log("üéõÔ∏è Kontrol modu: RAW PWM")
            self.gpio_integration.beep_success()
        elif key == ord('f'):
            self.control_mode = "PID"
            self.log("üéõÔ∏è Kontrol modu: PID")
            self.gpio_integration.beep_success()
        
        # Serial CONNECTION DEBUG - YENƒ∞! ‚≠ê
        elif key == ord('z') or key == ord('Z'):
            self.serial_connection_debug()
        
        # Men√º ge√ßi≈üleri
        elif key == ord('0'):
            self.current_menu = "mission_plan"
            self.log("üéØ G√∂rev planlama men√ºs√ºne ge√ßildi")
        elif key == ord('t') or key == ord('T'):
            self.current_menu = "test_scripts"
            self.log("üîß Test script men√ºs√ºne ge√ßildi")
        elif key == ord('g') or key == ord('G'):
            self.current_menu = "gpio_test"
            self.log("üîß GPIO/I2C test men√ºs√ºne ge√ßildi")
        
        # GPIO hƒ±zlƒ± testler
        elif key == ord('b') or key == ord('B'):
            self.gpio_integration.beep_warning()
            self.log("üîä Buzzer test - uyarƒ± sesi √ßalƒ±ndƒ±")
        
        # Hƒ±zlƒ± y√ºzd√ºrme modu
        elif key == ord('x') or key == ord('X'):
            self.quick_swim_commands()
        
        # Hƒ±zlƒ± y√ºzd√ºrme komutlarƒ± (sadece quick swim mode aktifse)
        elif hasattr(self, 'quick_swim_mode') and self.quick_swim_mode:
            if self.handle_quick_swim_command(key):
                return  # Komut ba≈üarƒ±lƒ±, diƒüer kontrolleri atla
        
        # Diƒüer √∂zellikler
        elif key == ord('c'):
            self.show_config_menu()
        elif key == ord('v'):
            self.show_vibration_data()
        elif key == ord('p'):
            self.show_gps_data()
    
    def serial_connection_debug(self):
        """Serial baƒülantƒ± debug - INSTANT TEST"""
        self.log("üîç Serial CONNECTION DEBUG BA≈ûLATILIYOR...")
        
        # MAVLink durumu
        if self.mavlink_available and self.mavlink and self.mavlink.connected:
            self.log(f"üì° Serial MAVLink Object: ‚úÖ EXISTS")
            self.log(f"üì° mavlink.connected: {getattr(self.mavlink, 'connected', 'N/A')}")
            self.log(f"üì° mavlink.master: {getattr(self.mavlink, 'master', 'N/A') is not None}")
            
            # Master durumu
            if hasattr(self.mavlink, 'master') and self.mavlink.master:
                try:
                    # Son mesajƒ± kontrol et
                    msg = self.mavlink.master.recv_match(blocking=False, timeout=0.1)
                    if msg:
                        self.log(f"üì° Son mesaj tipi: {msg.get_type()}")
                    else:
                        self.log("üì° Hi√ß mesaj yok")
                        
                    # IMU verisi test et - VE ALTERNATIVE
                    imu_test = self.mavlink.get_imu_data()
                    if imu_test:
                        self.log(f"üì° IMU test: ‚úÖ SUCCESS - {len(imu_test)} values")
                        self.log(f"üì° IMU sample: ax={imu_test[0]:.3f}, ay={imu_test[1]:.3f}, az={imu_test[2]:.3f}")
                    else:
                        self.log("üì° IMU test: ‚ùå FAILED - None return")
                        # Alternative test
                        if hasattr(self.mavlink, 'get_imu_data_alternative'):
                            imu_alt = self.mavlink.get_imu_data_alternative()
                            if imu_alt:
                                self.log(f"üì° IMU ALTERNATIVE: ‚úÖ SUCCESS - {len(imu_alt)} values")
                                self.log(f"üì° ALT sample: ax={imu_alt[0]:.3f}, gy={imu_alt[4]:.3f}, gz={imu_alt[5]:.3f}")
                            else:
                                self.log("üì° IMU ALTERNATIVE: ‚ùå FAILED")
                        
                except Exception as e:
                    self.log(f"üì° Master test error: {e}")
            else:
                self.log("üì° Master: ‚ùå NOT EXISTS")
        else:
            self.log("üì° Serial MAVLink Object: ‚ùå NOT EXISTS")
        
        # Thread durumu
        with self.data_lock:
            self.log(f"üîÑ Serial Data Connected: {self.tcp_data['connected']}")
            self.log(f"üîÑ Live IMU Connected: {self.live_imu['connected']}")
            self.log(f"üîÑ IMU Update Rate: {self.live_imu['update_rate']}Hz")
            
            last_packet = self.tcp_data.get('last_packet', 0)
            if last_packet > 0:
                data_age = time.time() - last_packet
                self.log(f"üîÑ Son veri: {data_age:.1f} saniye √∂nce")
            else:
                self.log("üîÑ Hi√ß veri alƒ±nmamƒ±≈ü")
        
        # Serial port kontrol√º - shell command
        try:
            import subprocess
            result = subprocess.run(['ss', '-tlnp'], capture_output=True, text=True, timeout=3)
            for line in result.stdout.split('\n'):
                if '5777' in line:
                    self.log(f"üîå Port 5777: {line.strip()}")
                    break
            else:
                self.log("üîå Port 5777: ‚ùå NOT LISTENING")
        except Exception as e:
            self.log(f"üîå Port check error: {e}")
        
        self.log("üîç Serial CONNECTION DEBUG TAMAMLANDI")
        self.gpio_integration.beep_success()
    
    def handle_gpio_test(self, key):
        """GPIO test men√ºs√º tu≈ülarƒ± - YENƒ∞!"""
        # LED testleri
        if key == ord('1'):
            self.gpio_integration.gpio.set_led('red', True, 100)
            self.log("üî¥ Kƒ±rmƒ±zƒ± LED a√ßƒ±ldƒ±")
            # 1 saniye sonra kapat
            threading.Timer(1.0, lambda: self.gpio_integration.gpio.set_led('red', False)).start()
        elif key == ord('2'):
            self.gpio_integration.gpio.set_led('green', True, 100)
            self.log("üü¢ Ye≈üil LED a√ßƒ±ldƒ±")
            threading.Timer(1.0, lambda: self.gpio_integration.gpio.set_led('green', False)).start()
        elif key == ord('3'):
            self.gpio_integration.gpio.set_led('blue', True, 100)
            self.log("üîµ Mavi LED a√ßƒ±ldƒ±")
            threading.Timer(1.0, lambda: self.gpio_integration.gpio.set_led('blue', False)).start()
        elif key == ord('4'):
            self.gpio_integration.gpio.set_led('warning', True)
            self.log("‚ö†Ô∏è Warning LED a√ßƒ±ldƒ±")
            threading.Timer(1.0, lambda: self.gpio_integration.gpio.set_led('warning', False)).start()
        elif key == ord('5'):
            self.gpio_integration.gpio.set_led('status', True)
            self.log("üìä Status LED a√ßƒ±ldƒ±")
            threading.Timer(1.0, lambda: self.gpio_integration.gpio.set_led('status', False)).start()
        elif key == ord('6'):
            # RGB LED renk d√∂ng√ºs√º
            def rgb_cycle():
                colors = [(100, 0, 0), (0, 100, 0), (0, 0, 100), (100, 100, 0), (100, 0, 100), (0, 100, 100)]
                for r, g, b in colors:
                    self.gpio_integration.gpio.set_rgb_led(r, g, b)
                    time.sleep(0.3)
                self.gpio_integration.gpio.set_rgb_led(0, 0, 0)
            threading.Thread(target=rgb_cycle, daemon=True).start()
            self.log("üåà RGB LED renk d√∂ng√ºs√º ba≈ülatƒ±ldƒ±")
        
        # Buzzer testleri
        elif key == ord('7'):
            self.gpio_integration.gpio.buzzer_beep(1000, 0.3, 50)
            self.log("üîä Buzzer beep testi (1000Hz)")
        elif key == ord('8'):
            # Alarm pattern
            def alarm_pattern():
                for _ in range(3):
                    self.gpio_integration.gpio.buzzer_beep(2000, 0.2, 70)
                    time.sleep(0.1)
                    self.gpio_integration.gpio.buzzer_beep(1000, 0.2, 70)
                    time.sleep(0.1)
            threading.Thread(target=alarm_pattern, daemon=True).start()
            self.log("üö® Buzzer alarm pattern √ßalƒ±ndƒ±")
        elif key == ord('9'):
            # Button durumu g√∂ster
            button_state = self.gpio_integration.read_button()
            self.log(f"üîò Button durumu: {'BASILDI' if button_state else 'BASILMADI'}")
        
        # I2C testleri
        elif key == ord('d') or key == ord('D'):
            if self.gpio_integration.depth_sensor_available:
                depth_data = self.gpio_integration.get_depth_data()
                if depth_data:
                    self.log(f"üåä D300 Test: {depth_data['depth_m']:.2f}m, {depth_data['temperature_c']:.1f}¬∞C")
                else:
                    self.log("‚ùå D300 veri alƒ±namadƒ±")
            else:
                self.log("‚ùå D300 sens√∂r√º hazƒ±r deƒüil")
        elif key == ord('s') or key == ord('S'):
            self.log("üîç I2C tarama ba≈ülatƒ±lƒ±yor...")
            # I2C scanner √ßalƒ±≈ütƒ±r
            try:
                result = subprocess.run([sys.executable, "i2c_scanner.py"], capture_output=True, text=True, timeout=10)
                for line in result.stdout.strip().split('\n')[-3:]:  # Son 3 satƒ±r
                    if line.strip():
                        self.log(f"I2C: {line}")
            except Exception as e:
                self.log(f"‚ùå I2C tarama hatasƒ±: {e}")
        elif key == ord('c') or key == ord('C'):
            if self.gpio_integration.depth_sensor:
                success = self.gpio_integration.depth_sensor.calibrate_surface()
                if success:
                    self.log("‚úÖ D300 y√ºzey kalibrasyonu tamamlandƒ±")
                else:
                    self.log("‚ùå D300 kalibrasyon ba≈üarƒ±sƒ±z")
            else:
                self.log("‚ùå D300 sens√∂r√º yok")
        
        # Men√º ge√ßi≈üi
        elif key == ord('b') or key == ord('B'):
            self.current_menu = "main"
            self.log("üîô Ana men√ºye d√∂n√ºld√º")
    
    def handle_mission_planning(self, key):
        """G√∂rev planlama tu≈ülarƒ±"""
        # G√∂rev ekleme
        if key in [ord('1'), ord('2'), ord('3'), ord('4'), ord('5'), ord('6'), ord('7'), ord('8'), ord('9')]:
            command = chr(key)
            value = self.get_mission_value_input(command)
            if value is not None:
                if self.mission_planner.add_mission(command, value):
                    cmd_name = self.mission_planner.mission_commands[command]['name']
                    self.log(f"‚úÖ G√∂rev eklendi: {cmd_name} ({value})")
                    self.gpio_integration.beep_success()
        
        # G√∂rev kontrol√º
        elif key == ord('\n') or key == ord('\r'):  # Enter
            if self.mission_planner.start_mission():
                self.log("üöÄ G√∂rev akƒ±≈üƒ± ba≈ülatƒ±ldƒ±!")
                self.gpio_integration.beep_warning()
                self.execute_mission_flow()
            else:
                self.log("‚ùå Ba≈ülatƒ±lacak g√∂rev yok!")
                self.gpio_integration.beep_error()
        
        elif key == ord('c') or key == ord('C'):
            self.mission_planner.clear_missions()
            self.log("üóëÔ∏è T√ºm g√∂revler temizlendi")
            self.gpio_integration.beep_success()
        
        elif key == ord('b') or key == ord('B'):
            self.current_menu = "main"
            self.log("üîô Ana men√ºye d√∂n√ºld√º")
    
    def handle_test_scripts(self, key):
        """Test script tu≈ülarƒ±"""
        # Script √ßalƒ±≈ütƒ±rma
        if key in [ord('1'), ord('2'), ord('3'), ord('4'), ord('5'), ord('6'), ord('7'), ord('8'), ord('9')]:
            script_id = chr(key)
            if self.test_scripts.run_script(script_id, self.test_script_callback):
                script_info = self.test_scripts.scripts.get(script_id, {})
                self.log(f"üîß Test ba≈ülatƒ±ldƒ±: {script_info.get('name', 'Unknown')}")
                self.gpio_integration.beep_success()
        
        # Script durdurma
        elif key == ord('s') or key == ord('S'):
            if self.test_scripts.running_script:
                self.log("‚èπÔ∏è √áalƒ±≈üan script durduruluyor...")
                self.gpio_integration.beep_warning()
                # Script durdurma i≈ülemi burada implement edilecek
            else:
                self.log("‚ö†Ô∏è √áalƒ±≈üan script yok")
        
        elif key == ord('b') or key == ord('B'):
            self.current_menu = "main"
            self.log("üîô Ana men√ºye d√∂n√ºld√º")
    
    def get_mission_value_input(self, command):
        """G√∂rev deƒüeri giri≈üi"""
        cmd_info = self.mission_planner.mission_commands.get(command, {})
        param_type = cmd_info.get('param_type', 'distance')
        
        if param_type == 'distance':
            prompt = "Mesafe (metre, 0.5-20): "
            default = 2.0
        elif param_type == 'angle':
            prompt = "A√ßƒ± (derece, -180 to 180): "
            default = 90.0
        elif param_type == 'time':
            prompt = "S√ºre (saniye, 1-30): "
            default = 3.0
        else:
            return default
        
        # Basit input sim√ºlasyonu - ger√ßek implementasyonda input penceresi a√ßƒ±lƒ±r
        return default  # ≈ûimdilik varsayƒ±lan deƒüer d√∂nd√ºr
    
    def execute_mission_flow(self):
        """G√∂rev akƒ±≈üƒ±nƒ± √ßalƒ±≈ütƒ±r"""
        def mission_executor():
            try:
                for mission in self.mission_planner.missions:
                    if not self.mission_planner.mission_active:
                        break
                    
                    mission['status'] = 'executing'
                    self.log(f"üéØ G√∂rev √ßalƒ±≈ütƒ±rƒ±lƒ±yor: {mission['name']}")
                    
                    # G√∂rev tipine g√∂re i≈ülem yap
                    success = self.execute_single_mission(mission)
                    
                    mission['status'] = 'completed' if success else 'failed'
                    
                    if not success:
                        self.log(f"‚ùå G√∂rev ba≈üarƒ±sƒ±z: {mission['name']}")
                        break
                    
                    time.sleep(0.5)  # G√∂revler arasƒ± bekleme
                
                self.mission_planner.mission_active = False
                self.log("‚úÖ G√∂rev akƒ±≈üƒ± tamamlandƒ±!")
                
            except Exception as e:
                self.log(f"‚ùå G√∂rev akƒ±≈üƒ± hatasƒ±: {e}")
                self.mission_planner.mission_active = False
        
        # Mission executor thread
        mission_thread = threading.Thread(target=mission_executor, daemon=True)
        mission_thread.start()
    
    def execute_single_mission(self, mission):
        """Tek g√∂rev √ßalƒ±≈ütƒ±r"""
        try:
            action = mission['command']
            value = mission['value']
            
            if not self.mavlink or not self.mavlink.connected or not self.armed:
                self.log("‚ùå G√∂rev i√ßin ARM gerekli!")
                return False
            
            # G√∂rev tipine g√∂re i≈ülem
            if action == 'F':
                return self.execute_forward(value)
            elif action == 'B':
                return self.execute_backward(value)
            elif action == 'L':
                return self.execute_left(value)
            elif action == 'R':
                return self.execute_right(value)
            elif action == 'U':
                return self.execute_up(value)
            elif action == 'D':
                return self.execute_down(value)
            elif action == 'Y':
                return self.execute_yaw(value)
            elif action == 'W':
                return self.execute_wait(value)
            elif action == 'S':
                return self.execute_surface()
            
            return False
            
        except Exception as e:
            self.log(f"‚ùå G√∂rev √ßalƒ±≈ütƒ±rma hatasƒ±: {e}")
            return False
    
    def execute_forward(self, distance):
        """ƒ∞leri/geri hareket"""
        duration = abs(distance) * 2  # 2 saniye/metre
        motor_value = 30 if distance > 0 else -30
        
        for i in range(int(duration * 10)):  # 10Hz
            if not self.mission_planner.mission_active:
                return False
            
            self.motor_value = motor_value
            self.send_motor_command()
            time.sleep(0.1)
        
        # Motor'u durdur
        self.motor_value = 0
        self.send_motor_command()
        return True
    
    def execute_backward(self, distance):
        """ƒ∞leri/geri hareket"""
        return self.execute_forward(-distance)
    
    def execute_left(self, angle):
        """Sol d√∂n√º≈ü"""
        duration = abs(angle) / 45  # 45¬∞/saniye
        yaw_value = -angle * 30  # ¬±30¬∞ yaw servo
        
        for i in range(int(duration * 10)):  # 10Hz
            if not self.mission_planner.mission_active:
                return False
            
            self.servo_values['yaw'] = yaw_value
            self.send_servo_commands()
            time.sleep(0.1)
        
        # Neutral'a getir
        self.servo_values['yaw'] = 0
        self.send_servo_commands()
        return True
    
    def execute_right(self, angle):
        """Saƒü d√∂n√º≈ü"""
        return self.execute_left(-angle)
    
    def execute_up(self, distance):
        """Yukarƒ± hareket"""
        duration = distance * 3  # 3 saniye/metre
        pitch_value = distance * 20  # ¬±20¬∞ pitch
        
        for i in range(int(duration * 10)):  # 10Hz
            if not self.mission_planner.mission_active:
                return False
            
            self.servo_values['pitch'] = pitch_value
            self.send_servo_commands()
            time.sleep(0.1)
        
        # Neutral'a getir
        self.servo_values['pitch'] = 0
        self.send_servo_commands()
        return True
    
    def execute_down(self, distance):
        """A≈üaƒüƒ± hareket"""
        return self.execute_up(-distance)
    
    def execute_yaw(self, angle):
        """Yaw d√∂n√º≈ü√º"""
        duration = abs(angle) / 45  # 45¬∞/saniye
        yaw_value = angle * 30  # ¬±30¬∞ yaw servo
        
        for i in range(int(duration * 10)):  # 10Hz
            if not self.mission_planner.mission_active:
                return False
            
            self.servo_values['yaw'] = yaw_value
            self.send_servo_commands()
            time.sleep(0.1)
        
        # Neutral'a getir
        self.servo_values['yaw'] = 0
        self.send_servo_commands()
        return True
    
    def execute_wait(self, duration):
        """S√ºre bekleme"""
        time.sleep(duration)
        return True
    
    def execute_surface(self):
        """Y√ºzeye √ßƒ±kma"""
        return True
    
    def test_script_callback(self, script_id, success, stdout, stderr):
        """Test script callback"""
        script_info = self.test_scripts.scripts.get(script_id, {})
        script_name = script_info.get('name', 'Unknown')
        
        if success:
            self.log(f"‚úÖ Test tamamlandƒ±: {script_name}")
            # Stdout'un son birka√ß satƒ±rƒ±nƒ± g√∂ster
            for line in stdout.strip().split('\n')[-2:]:
                if line.strip():
                    self.log(f"   {line}")
        else:
            self.log(f"‚ùå Test ba≈üarƒ±sƒ±z: {script_name}")
            # Stderr'in son birka√ß satƒ±rƒ±nƒ± g√∂ster
            for line in stderr.strip().split('\n')[-2:]:
                if line.strip():
                    self.log(f"   {line}")
    
    def update_servo_control(self):
        """Real-time servo kontrol√º - YAW PROBLEMƒ∞ D√úZELTƒ∞LDƒ∞"""
        # Smooth control parameters
        pitch_step = 2.5
        roll_step = 2.5
        yaw_step = 4.0  # YAW i√ßin daha b√ºy√ºk adƒ±m
        decay_rate = 1.5  # Otomatik sƒ±fƒ±rlama hƒ±zƒ±
        
        # Pitch kontrol - SMOOTH
        if 'w' in self.active_keys:
            self.servo_values['pitch'] = min(45, self.servo_values['pitch'] + pitch_step)
        elif 's' in self.active_keys:
            self.servo_values['pitch'] = max(-45, self.servo_values['pitch'] - pitch_step)
        else:
            # Smooth otomatik sƒ±fƒ±rlama
            if abs(self.servo_values['pitch']) > 0.5:
                if self.servo_values['pitch'] > 0:
                    self.servo_values['pitch'] = max(0, self.servo_values['pitch'] - decay_rate)
                else:
                    self.servo_values['pitch'] = min(0, self.servo_values['pitch'] + decay_rate)
            else:
                self.servo_values['pitch'] = 0
        
        # Roll kontrol - SMOOTH
        if 'a' in self.active_keys:
            self.servo_values['roll'] = min(45, self.servo_values['roll'] + roll_step)
        elif 'd' in self.active_keys:
            self.servo_values['roll'] = max(-45, self.servo_values['roll'] - roll_step)
        else:
            # Smooth otomatik sƒ±fƒ±rlama
            if abs(self.servo_values['roll']) > 0.5:
                if self.servo_values['roll'] > 0:
                    self.servo_values['roll'] = max(0, self.servo_values['roll'] - decay_rate)
                else:
                    self.servo_values['roll'] = min(0, self.servo_values['roll'] + decay_rate)
            else:
                self.servo_values['roll'] = 0
        
        # YAW kontrol - TAMAMEN YENƒ∞ VE G√ú√áLENDƒ∞Rƒ∞LMƒ∞≈û SYSTEM
        yaw_changed = False
        
        if 'q' in self.active_keys:
            old_yaw = self.servo_values['yaw']
            self.servo_values['yaw'] = min(45, self.servo_values['yaw'] + yaw_step)
            yaw_changed = True
            
            # Sadece deƒüer deƒüi≈ütiƒüinde log
            if self.servo_values['yaw'] != old_yaw:
                self.log(f"üéØ YAW RIGHT: {old_yaw:.1f}¬∞ ‚Üí {self.servo_values['yaw']:.1f}¬∞ (Q key active)")
                
        elif 'e' in self.active_keys:
            old_yaw = self.servo_values['yaw']
            self.servo_values['yaw'] = max(-45, self.servo_values['yaw'] - yaw_step)
            yaw_changed = True
            
            # Sadece deƒüer deƒüi≈ütiƒüinde log
            if self.servo_values['yaw'] != old_yaw:
                self.log(f"üéØ YAW LEFT: {old_yaw:.1f}¬∞ ‚Üí {self.servo_values['yaw']:.1f}¬∞ (E key active)")
                
        else:
            # YAW Smooth auto-return to neutral - IMPROVED
            if abs(self.servo_values['yaw']) > 0.8:  # Threshold artƒ±rƒ±ldƒ±
                old_yaw = self.servo_values['yaw']
                
                if self.servo_values['yaw'] > 0:
                    self.servo_values['yaw'] = max(0, self.servo_values['yaw'] - (decay_rate * 1.2))
                else:
                    self.servo_values['yaw'] = min(0, self.servo_values['yaw'] + (decay_rate * 1.2))
                
                # Neutral'a yakƒ±n deƒüerler i√ßin debug
                if abs(old_yaw) > 1 and abs(self.servo_values['yaw']) <= 1:
                    self.log(f"üéØ YAW NEUTRAL: {old_yaw:.1f}¬∞ ‚Üí {self.servo_values['yaw']:.1f}¬∞ (auto-return)")
                    
            elif abs(self.servo_values['yaw']) <= 0.8:
                # K√º√ß√ºk deƒüerleri direkt sƒ±fƒ±rla
                if self.servo_values['yaw'] != 0:
                    self.log(f"üéØ YAW ZERO: {self.servo_values['yaw']:.1f}¬∞ ‚Üí 0.0¬∞ (force neutral)")
                self.servo_values['yaw'] = 0
        
        # Servo komutlarƒ±nƒ± g√∂nder - YAW priority ile
        self.send_servo_commands(yaw_priority=yaw_changed)
        
        # Tu≈ü durumunu temizle
        self.active_keys.clear()
    
    def send_servo_commands(self, yaw_priority=False):
        """Servo komutlarƒ±nƒ± TCP √ºzerinden g√∂nder - YAW PROBLEMƒ∞ √á√ñZ√úLD√ú"""
        
        # Logging strategy - sadece √∂nemli deƒüi≈üiklikler
        if yaw_priority and abs(self.servo_values['yaw']) > 0:
            # YAW hareketi aktif - detaylƒ± log
            self.log(f"üéØ YAW COMMAND: {self.servo_values['yaw']:.1f}¬∞ | R:{self.servo_values['roll']:.1f}¬∞ P:{self.servo_values['pitch']:.1f}¬∞")
        elif not yaw_priority and (abs(self.servo_values['roll']) > 2 or abs(self.servo_values['pitch']) > 2):
            # Roll/Pitch hareketi - normal log
            self.log(f"üì° SERVO: R={self.servo_values['roll']:.1f}¬∞ P={self.servo_values['pitch']:.1f}¬∞ Y={self.servo_values['yaw']:.1f}¬∞")
        
        # MAVLink baƒülantƒ± kontrol√º - STREAMLINED
        if not self.mavlink or not self.mavlink.connected:
            # Sadece YAW aktifken uyarƒ± g√∂ster (spam √∂nleme)
            if yaw_priority:
                self.log("‚ö†Ô∏è Serial MAVLink disconnected - YAW command ignored!")
            return
            
        if not self.armed:
            # Sadece YAW aktifken uyarƒ± g√∂ster (spam √∂nleme)
            if yaw_priority:
                self.log("‚ö†Ô∏è DISARMED - YAW ignored! Press SPACE to ARM")
            return
        
        # GER√áEK SERVO KOMUTLARI - High Priority YAW
        try:
            # Real-time servo command transmission
            if self.control_mode == "RAW":
                success = self.mavlink.control_servos_raw(
                    self.servo_values['roll'],
                    self.servo_values['pitch'],
                    self.servo_values['yaw']
                )
            else:  # PID mode
                success = self.mavlink.control_servos_pid(
                    self.servo_values['roll'],
                    self.servo_values['pitch'],
                    self.servo_values['yaw']
                )
            
            # Success feedback - sadece YAW priority'sinde
            if yaw_priority and success:
                self.log(f"‚úÖ YAW transmitted: {self.servo_values['yaw']:.1f}¬∞ via {self.control_mode}")
                
        except Exception as e:
            # Error feedback - sadece √∂nemli hatalar
            if yaw_priority or abs(self.servo_values['roll']) > 10 or abs(self.servo_values['pitch']) > 10:
                self.log(f"‚ùå Servo transmission error: {e}")
                self.log(f"üîß Values: R={self.servo_values['roll']:.1f}¬∞ P={self.servo_values['pitch']:.1f}¬∞ Y={self.servo_values['yaw']:.1f}¬∞")
    
    def send_motor_command(self):
        """Motor komutunu TCP √ºzerinden g√∂nder"""
        if not self.mavlink or not self.mavlink.connected or not self.armed:
            return
        
        try:
            # Motor PWM hesapla
            pwm_limits = self.config["pixhawk"]["pwm_limits"]
            neutral = pwm_limits["motor_stop"]
            pwm_range = (pwm_limits["motor_max"] - pwm_limits["motor_min"]) // 2
            
            pwm_value = neutral + (self.motor_value * pwm_range // 100)
            pwm_value = max(pwm_limits["motor_min"], min(pwm_limits["motor_max"], pwm_value))
            
            self.mavlink.send_raw_motor_pwm(int(pwm_value))
        except Exception as e:
            self.log(f"‚ùå Motor komut hatasƒ±: {e}")
    
    def toggle_arm(self):
        """ARM/DISARM toggle - GPIO entegrasyonu ile"""
        if not self.mavlink or not self.mavlink.connected:
            self.log("‚ùå Serial MAVLink baƒülantƒ±sƒ± yok!")
            self.gpio_integration.beep_error()
            return
        
        try:
            # Basit ARM/DISARM toggle
            if self.armed:
                # DISARM
                self.log("üü¢ DISARM ediliyor...")
                self.mavlink.disarm_system()
                self.armed = False
                self.log("üü¢ GUI DISARM edildi (servo komutlarƒ± artƒ±k g√∂nderilmez)")
                
                # GPIO LED g√ºncelle - YENƒ∞!
                self.gpio_integration.set_connection_status_led(True, False)
                self.gpio_integration.beep_success()
                
                # Kontrolleri sƒ±fƒ±rla
                self.servo_values = {'roll': 0, 'pitch': 0, 'yaw': 0}
                self.motor_value = 0
                
            else:
                # ARM
                self.log("üî¥ ARM ediliyor...")
                if self.mavlink.arm_system():
                    self.armed = True
                    self.log("üî¥ GUI ARM edildi! Servo komutlarƒ± MAVLink'e g√∂nderilecek!")
                    self.log("üéÆ Artƒ±k Q/E, W/S, A/D, J/K/I/M tu≈ülarƒ± kontrolleri hareket ettirir!")
                    
                    # GPIO LED g√ºncelle - YENƒ∞!
                    self.gpio_integration.set_connection_status_led(True, True)
                    self.gpio_integration.beep_warning()  # ARM uyarƒ±sƒ±
                    
                else:
                    self.log("‚ö†Ô∏è ARM ba≈üarƒ±sƒ±z ama GUI ARM moduna ge√ßiyor (test i√ßin)")
                    self.armed = True  # Test i√ßin GUI'de ARM yap
                    self.log("üí° Manuel kontroller √ßalƒ±≈üƒ±r ama servo'lar hareket etmez")
                    
                    # GPIO uyarƒ± - YENƒ∞!
                    self.gpio_integration.set_connection_status_led(True, True)
                    self.gpio_integration.beep_error()
            
        except Exception as e:
            self.log(f"‚ùå ARM/DISARM hatasƒ±: {e}")
            # Hata olsa bile GUI durumunu deƒüi≈ütir
            self.armed = not self.armed
            status = "ARM" if self.armed else "DISARM"
            self.log(f"üîÑ GUI {status} durumuna ge√ßirildi (test i√ßin)")
            
            # GPIO hata sinyali - YENƒ∞!
            self.gpio_integration.beep_error()
            self.gpio_integration.set_connection_status_led(True, self.armed)
    
    def show_config_menu(self):
        """Konfig√ºrasyon men√ºs√º"""
        self.log("üîß Konfig√ºrasyon men√ºs√º a√ßƒ±lƒ±yor...")
        # Basit implementasyon - detaylarƒ± daha sonra
    
    def show_vibration_data(self):
        """Vibration verilerini g√∂ster - OPSIYONEL"""
        if self.mavlink and self.mavlink.connected:
            self.log("üìà Vibration monitoring ≈üimdilik devre dƒ±≈üƒ±")
        else:
            self.log("‚ö†Ô∏è MAVLink baƒülantƒ±sƒ± gerekli")
    
    def show_gps_data(self):
        """GPS verilerini g√∂ster - OPSIYONEL"""
        if self.mavlink and self.mavlink.connected:
            gps_data = self.mavlink.get_gps_data()
            if gps_data:
                lat, lon, alt, sats = gps_data
                self.log(f"üó∫Ô∏è GPS: Lat={lat:.6f}¬∞ Lon={lon:.6f}¬∞ Alt={alt:.1f}m Sats={sats}")
                self.gpio_integration.beep_success()
            else:
                self.log("üó∫Ô∏è GPS verisi alƒ±namadƒ±")
                self.gpio_integration.beep_error()
        else:
            self.log("‚ö†Ô∏è MAVLink baƒülantƒ±sƒ± gerekli")
            self.gpio_integration.beep_error()
    
    def quick_swim_commands(self):
        """Hƒ±zlƒ± y√ºzd√ºrme komutlarƒ± - Real-time kontrol"""
        if not self.mavlink or not self.mavlink.connected:
            self.log("‚ùå MAVLink baƒülantƒ±sƒ± gerekli!")
            return
        
        self.log("\nüèä HIZLI Y√úZDƒ∞RME KOMUTLARI AKTƒ∞F!")
        self.log("üéÆ Kontroller:")
        self.log("   1,2,3 = Y√ºzd√ºrme seviyeleri (y√ºzey, sƒ±ƒü, derin)")
        self.log("   4,5 = Sol/Saƒü d√∂n√º≈ü")
        self.log("   6,7 = ƒ∞leri/Geri")
        self.log("   0 = Neutral (dur)")
        self.log("   ESC = √áƒ±kƒ±≈ü")
        
        # Quick swim mode flag
        self.quick_swim_mode = True
        
        # Pre-defined PWM values for quick commands
        self.quick_swim_pwm = {
            'neutral': 1500,
            'motor_stop': 1500,
            'surface_swim': {'fins': 1450, 'motor': 1520},   # Hafif yukarƒ± + yava≈ü
            'shallow_dive': {'fins': 1550, 'motor': 1550},   # Hafif a≈üaƒüƒ± + orta
            'deep_dive': {'fins': 1600, 'motor': 1550},      # Orta a≈üaƒüƒ± + orta  
            'turn_left': {'left': 1550, 'right': 1450, 'motor': 1530},
            'turn_right': {'left': 1450, 'right': 1550, 'motor': 1530},
            'forward': {'fins': 1500, 'motor': 1600},        # Neutral fins + hƒ±zlƒ±
            'reverse': {'fins': 1500, 'motor': 1450}         # Neutral fins + geri
        }
        
        self.log("‚úÖ Hƒ±zlƒ± y√ºzd√ºrme modu aktif - sayƒ± tu≈ülarƒ±nƒ± kullanƒ±n!")
    
    def handle_quick_swim_command(self, key):
        """Hƒ±zlƒ± y√ºzd√ºrme komutunu i≈üle"""
        if not hasattr(self, 'quick_swim_mode') or not self.quick_swim_mode:
            return False
        
        if not self.mavlink or not self.mavlink.connected:
            return False
        
        try:
            # Servo channels (X-wing config)
            channels = {
                'front_left': 1,   # AUX1
                'front_right': 3,  # AUX3
                'rear_left': 4,    # AUX4
                'rear_right': 5,   # AUX5
                'motor': 6         # AUX6
            }
            
            if key == ord('0'):
                # Neutral position
                for servo in ['front_left', 'front_right', 'rear_left', 'rear_right']:
                    self.mavlink.set_servo_pwm(channels[servo], self.quick_swim_pwm['neutral'])
                self.mavlink.set_servo_pwm(channels['motor'], self.quick_swim_pwm['motor_stop'])
                self.log("üèä Neutral pozisyon - durma")
                
            elif key == ord('1'):
                # Surface swim
                pwm = self.quick_swim_pwm['surface_swim']['fins']
                motor_pwm = self.quick_swim_pwm['surface_swim']['motor']
                for servo in ['front_left', 'front_right', 'rear_left', 'rear_right']:
                    self.mavlink.set_servo_pwm(channels[servo], pwm)
                self.mavlink.set_servo_pwm(channels['motor'], motor_pwm)
                self.log("üèä Su y√ºzeyinde y√ºzd√ºrme - t√ºm finler hafif yukarƒ±")
                
            elif key == ord('2'):
                # Shallow dive
                pwm = self.quick_swim_pwm['shallow_dive']['fins']
                motor_pwm = self.quick_swim_pwm['shallow_dive']['motor']
                for servo in ['front_left', 'front_right', 'rear_left', 'rear_right']:
                    self.mavlink.set_servo_pwm(channels[servo], pwm)
                self.mavlink.set_servo_pwm(channels['motor'], motor_pwm)
                self.log("üèä Sƒ±ƒü dalƒ±≈ü - 0.5m derinlik")
                
            elif key == ord('3'):
                # Deep dive
                pwm = self.quick_swim_pwm['deep_dive']['fins']
                motor_pwm = self.quick_swim_pwm['deep_dive']['motor']
                for servo in ['front_left', 'front_right', 'rear_left', 'rear_right']:
                    self.mavlink.set_servo_pwm(channels[servo], pwm)
                self.mavlink.set_servo_pwm(channels['motor'], motor_pwm)
                self.log("üèä Derin dalƒ±≈ü - 1m derinlik")
                
            elif key == ord('4'):
                # Turn left
                left_pwm = self.quick_swim_pwm['turn_left']['left']
                right_pwm = self.quick_swim_pwm['turn_left']['right']
                motor_pwm = self.quick_swim_pwm['turn_left']['motor']
                
                self.mavlink.set_servo_pwm(channels['front_left'], left_pwm)
                self.mavlink.set_servo_pwm(channels['rear_left'], left_pwm)
                self.mavlink.set_servo_pwm(channels['front_right'], right_pwm)
                self.mavlink.set_servo_pwm(channels['rear_right'], right_pwm)
                self.mavlink.set_servo_pwm(channels['motor'], motor_pwm)
                self.log("üèä Sol d√∂n√º≈ü - X-wing asimetrik kontrol")
                
            elif key == ord('5'):
                # Turn right
                left_pwm = self.quick_swim_pwm['turn_right']['left']
                right_pwm = self.quick_swim_pwm['turn_right']['right']
                motor_pwm = self.quick_swim_pwm['turn_right']['motor']
                
                self.mavlink.set_servo_pwm(channels['front_left'], left_pwm)
                self.mavlink.set_servo_pwm(channels['rear_left'], left_pwm)
                self.mavlink.set_servo_pwm(channels['front_right'], right_pwm)
                self.mavlink.set_servo_pwm(channels['rear_right'], right_pwm)
                self.mavlink.set_servo_pwm(channels['motor'], motor_pwm)
                self.log("üèä Saƒü d√∂n√º≈ü - X-wing asimetrik kontrol")
                
            elif key == ord('6'):
                # Forward
                pwm = self.quick_swim_pwm['forward']['fins']
                motor_pwm = self.quick_swim_pwm['forward']['motor']
                for servo in ['front_left', 'front_right', 'rear_left', 'rear_right']:
                    self.mavlink.set_servo_pwm(channels[servo], pwm)
                self.mavlink.set_servo_pwm(channels['motor'], motor_pwm)
                self.log("üèä Hƒ±zlƒ± ileri - d√ºz y√ºzd√ºrme")
                
            elif key == ord('7'):
                # Reverse
                pwm = self.quick_swim_pwm['reverse']['fins']
                motor_pwm = self.quick_swim_pwm['reverse']['motor']
                for servo in ['front_left', 'front_right', 'rear_left', 'rear_right']:
                    self.mavlink.set_servo_pwm(channels[servo], pwm)
                self.mavlink.set_servo_pwm(channels['motor'], motor_pwm)
                self.log("üèä Geri hareket")
                
            elif key == 27:  # ESC key
                # Exit quick swim mode
                self.quick_swim_mode = False
                # Return to neutral
                for servo in ['front_left', 'front_right', 'rear_left', 'rear_right']:
                    self.mavlink.set_servo_pwm(channels[servo], self.quick_swim_pwm['neutral'])
                self.mavlink.set_servo_pwm(channels['motor'], self.quick_swim_pwm['motor_stop'])
                self.log("üèä Hƒ±zlƒ± y√ºzd√ºrme modu kapatƒ±ldƒ± - normal kontrollere d√∂n√ºld√º")
                return True
            else:
                return False
            
            # GPIO feedback
            if hasattr(self, 'gpio_integration') and self.gpio_integration:
                self.gpio_integration.beep_success()
            
            return True
            
        except Exception as e:
            self.log(f"‚ùå Hƒ±zlƒ± y√ºzd√ºrme komutu hatasƒ±: {e}")
            return False
    
    def main_loop(self):
        """Ana d√∂ng√º - optimize edilmi≈ü"""
        last_ui_update = time.time()
        last_servo_update = time.time()
        
        while self.running:
            try:
                current_time = time.time()
                
                # UI g√ºncelleme (20Hz)
                if current_time - last_ui_update > 0.05:
                    self.stdscr.erase()
                    
                    # UI bile≈üenlerini √ßiz
                    self.draw_header()
                    self.draw_live_imu_display()
                    self.draw_depth_sensor_display()
                    self.draw_controls_and_menu()
                    self.draw_logs()
                    
                    # Ekranƒ± yenile
                    self.stdscr.refresh()
                    last_ui_update = current_time
                
                # Klavye giri≈üi
                self.handle_keyboard()
                
                # Real-time servo kontrol√º (50Hz)
                if current_time - last_servo_update > 0.02:
                    self.update_servo_control()
                    last_servo_update = current_time
                
                # CPU efficiency
                time.sleep(0.001)
                    
            except KeyboardInterrupt:
                self.running = False
            except Exception as e:
                self.log(f"‚ùå Ana d√∂ng√º hatasƒ±: {e}")
    
    def cleanup(self):
        """Temizlik i≈ülemleri - GPIO/I2C Dƒ∞L entegrasyonu"""
        self.log("üîÑ Sistem kapatƒ±lƒ±yor...")
        
        # Thread'leri durdur
        self.tcp_running = False
        if self.tcp_thread and self.tcp_thread.is_alive():
            self.tcp_thread.join(timeout=2)
        
        # G√∂revleri durdur
        self.mission_planner.mission_active = False
        
        # Servolar neutral'a
        if self.mavlink and self.mavlink.connected:
            try:
                self.mavlink.emergency_stop()
                self.mavlink.disconnect()
            except:
                pass
        
        # GPIO ve I2C temizliƒüi - YENƒ∞!
        if self.gpio_integration:
            try:
                # Son ses - sistem kapanƒ±yor
                self.gpio_integration.beep_warning()
                self.gpio_integration.set_rgb_led(100, 100, 0)  # Turuncu
                time.sleep(0.2)
                self.gpio_integration.set_rgb_led(0, 0, 0)  # Kapat
                
                # GPIO/I2C cleanup
                self.gpio_integration.cleanup()
            except Exception as e:
                self.log(f"‚ö†Ô∏è GPIO cleanup hatasƒ±: {e}")
        
        self.log("‚úÖ Sistem temizlendi!")
    
    def run(self):
        """Uygulamayƒ± √ßalƒ±≈ütƒ±r"""
        # Curses uygulamasƒ±nƒ± ba≈ülat
        try:
            curses.wrapper(self._curses_main)
        except Exception as e:
            pass  # Curses i√ßinde print yapma
        finally:
            self.cleanup()
    
    def _curses_main(self, stdscr):
        """Curses ana fonksiyonu"""
        self.init_curses(stdscr)
        # Sistem bile≈üenlerini curses SONRASI ba≈ülat
        self.init_systems()
        self.main_loop()

if __name__ == "__main__":
    # √áalƒ±≈üma dizinini kontrol et
    if not os.path.exists("config"):
        sys.exit(1)
    
    # Terminal GUI'yi ba≈ülat
    try:
        gui = AdvancedTerminalGUI()
        gui.run()
    except KeyboardInterrupt:
        pass
    except ImportError as e:
        sys.exit(1)
    except Exception as e:
        import traceback
        traceback.print_exc()
        sys.exit(1) 